import os
from datetime import datetime, timedelta

import awswrangler as wr
import boto3
from botocore.exceptions import ClientError
from bs4 import BeautifulSoup
import logging
import pandas as pd
import requests
import sentry_sdk

from .utils import get_leading_zeroes

today = datetime.now().date()

def write_to_s3(
    file_name: str, df: pd.DataFrame, bucket: str = os.environ.get("S3_BUCKET")
):
    """
    S3 Function using awswrangler to write file.  Only supports parquet right now.

    Args:
        file_name (str): The base name of the file (boxscores, opp_stats)

        df (pd.DataFrame): The Pandas DataFrame to write

        bucket (str): The Bucket to write to.  Defaults to `os.environ.get('S3_BUCKET')`

    Returns:
        Writes the Pandas DataFrame to an S3 File.

    """
    month_prefix = get_leading_zeroes(datetime.now().month)
    # df['file_name'] = f'{file_name}-{today}.parquet'
    try:
        if len(df) == 0:
            logging.info(f"Not storing {file_name} to s3 because it's empty.")
            pass
        elif df.schema == "Validated":
            wr.s3.to_parquet(
                df=df,
                path=f"s3://{bucket}/{file_name}/validated/{month_prefix}/{file_name}-{today}.parquet",
                index=False,
            )
            logging.info(
                f"Storing {len(df)} {file_name} rows to S3 (s3://{bucket}/{file_name}/validated/{month_prefix}/{file_name}-{today}.parquet)"
            )
            pass
        else:
            wr.s3.to_parquet(
                df=df,
                path=f"s3://{bucket}/{file_name}/invalidated/{month_prefix}/{file_name}-{today}.parquet",
                index=False,
            )
            logging.info(
                f"Storing {len(df)} {file_name} rows to S3 (s3://{bucket}/{file_name}/invalidated/{month_prefix}/{file_name}-{today}.parquet)"
            )
            pass
    except BaseException as error:
        logging.error(f"S3 Storage Function Failed {file_name}, {error}")
        sentry_sdk.capture_exception(error)
        pass

def send_aws_email(logs: pd.DataFrame):
    """
    Email function utilizing boto3, has to be set up with SES in AWS and env variables passed in via Terraform.
    The actual email code is copied from aws/boto3 and the subject / message should go in the subject / body_html variables.

    Args:
        logs (DataFrame): The log file name generated by the script.

    Returns:
        Sends an email out upon every script execution, including errors (if any)
    """
    sender = os.environ.get("USER_EMAIL")
    recipient = os.environ.get("USER_EMAIL")
    aws_region = "us-east-1"
    subject = f"NBA ELT PIPELINE - {str(len(logs))} Alert Fails for {str(today)}"
    body_html = message = f"""\
<h3>Errors:</h3>
                   {logs.to_html()}"""

    charset = "UTF-8"
    client = boto3.client("ses", region_name=aws_region)
    try:
        response = client.send_email(
            Destination={"ToAddresses": [recipient,],},
            Message={
                "Body": {
                    "Html": {"Charset": charset, "Data": body_html,},
                    "Text": {"Charset": charset, "Data": body_html,},
                },
                "Subject": {"Charset": charset, "Data": subject,},
            },
            Source=sender,
        )
    except ClientError as e:
        logging.error(e.response["Error"]["Message"])
    else:
        logging.info("Email sent! Message ID:"),
        logging.info(response["MessageId"])


# DEPRECATING this as of 2022-04-25 - i send emails everyday now regardless of pass or fail
def execute_email_function(logs: pd.DataFrame):
    """
    Email function that executes the email function upon script finishing.
    This is really not necessary; originally thought i wouldn't email if no errors would found but now i send it everyday regardless.

    Args:
        logs (DataFrame): The log file name generated by the script.

    Returns:
        Holds the actual send_email logic and executes if invoked as a script (aka on ECS)
    """
    try:
        if len(logs) > 0:
            logging.info("Sending Email")
            send_aws_email(logs)
        elif len(logs) == 0:
            logging.info("No Errors!")
            send_aws_email(logs)
    except BaseException as error:
        logging.error(f"Failed Email Alert, {error}")
        sentry_sdk.capture_exception(error)
