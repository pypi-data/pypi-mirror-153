# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['site_config',
 'site_config.backends',
 'site_config.backends.model_backend',
 'site_config.backends.settings_backend',
 'site_config.tests']

package_data = \
{'': ['*'],
 'site_config': ['templates/admin/site_config/application/*',
                 'templates/admin/site_config/website/*',
                 'templates/site_config/*']}

install_requires = \
['django>=3.2,<4.0']

setup_kwargs = {
    'name': 'site-config',
    'version': '2.0.1',
    'description': 'Django configuration Utility to manage multiple "websites" in a project.',
    'long_description': '## ABOUT ##\n\n[![Build Status](https://travis-ci.org/ImaginaryLandscape/django_site_config.svg?branch=master)](https://travis-ci.org/ImaginaryLandscape/django_site_config)\n[![Downloads](https://pypip.in/download/site_config/badge.svg)](https://pypi.python.org/pypi/site_config/)\n\nThis module provides you an API that lets you code django applications such that\nthose apps can segment themselves into multiple sections and have different\nsettings for each section.\n\nFor example, say I want to use the same app under two different url paths and\nhave different behavior (different settings) for both.\n\n    /mysite1/myapp/\n    /mysite2/myapp/\n\nAlso, say I want to enable or disable individual apps on those different urls,\nvia an admin interface.\n\nAlso, say I want to have a consistent way to define settings for those apps.\n\n\nThis module helps you to accomplish those things. \n\n## INSTALL ##\n\nInstall from pip\n\n    pip install site-config\n\nInstall from Github\n\n    git clone https://github.com/ImaginaryLandscape/django_site_config.git\n\n\n## CONFIGURATION ##\n\nThis application allows you to specify different siteconfig backends.  The\nsiteconfig backend is responsible for getting and setting settings from/to a\npersistent location.\n\nCurrently, two backends are present in this module:\n\n -   model_backend\n -   settings_backend\n  \nThe model_backend stores configuration settings in a set of database models.  It\nallows for customizing the settings for a given app inside of the admin\ninterface and allows for different settings for different \'websites\' inside an\napp.  Choosing this backend enables an Django admin module for setting these\nsettings.\n\nThe settings_backend is a simple backend that uses settings.py.  This is not\ndynamic; when an application needs a setting, this backend just looks it up from\nsettings.py.\n\n\nAdd to INSTALLED_APPS in settings.py\n\n    \'site_config\',\n    \n    # If using model_backend\n    \'site_config.backends.model_backend\',\n     \n    # if using settings_backend\n    \'site_config.backends.settings_backend\',\n\n\nSite specific base templates may also be used if the following context processor\nis add to `TEMPLATE_CONTEXT_PROCESSORS` in settings.py\n\n    \'site_config.context_processors.decide_base_template\'\n\nThis sets a new context variable `base_template` so that the contents of your\n`base.html` template can extend a variable.  Instead of including all template\nlogic in your projects `base.html` template, you can move this logic to another\ntemplate (`base_site.html`, for instance) and have `base.html` be:\n\n    {% extends base_template|default:"base_site.html" %}\n\nNow in much the same way you can override templates (explained later in this\ndocument), you can create a `base_site.html` template inside your site\'s\ntemplate folder that will be used if present.\n\n### GLOBAL SETTINGS in settings.py ###\n\nSITECONFIG_BACKEND_DEFAULT (optional) = This specifies the default backend that\nis to be used.  If this setting is not defined, it defaults to the model\nbackend.\n\nValid values for this are as follows:\n\n    "site_config.backends.model_backend.DatabaseBackend"  # model_backend\n    "site_config.backends.settings_backend.SettingsBackend"  # settings_backend\n\n\nSITECONFIG_BASE_TEMPLATE (optional) = This specifies what the default base\ntemplate should be when using the `decide_base_template` context processor.  If\nthis context processor is not used, this setting has no effect.\n\n\n### CONFIGURING THE settings_backend ###\n\nSet the following in settings.py\n\n- SITECONFIG_SITEAPP_STATUS (optional) - This sets whether or not apps using\n   this module should be marked as active or not.  Valid values are: "disabled",\n   "curtained", or "enabled" The default is "enabled"\n\n- SITECONFIG_CURTAIN_MESSAGE (optional) = This sets the curtain message string\n   when SITECONFIG_SITEAPP_STATUS is set to "curtained".\n\n\n### CONFIGURING THE model_backend ###\n  \nYou need to run the following if using the model_backend:\n\n    ./manage.py syncdb\n    ./manage.py migrate \n\n\nIf the model backend is used, the Website, Application, and WebsiteApplication\nmodels defined in models.py should appear in the Django admin. If the settings\nbackend is used, they should not appear.\n\n\n## USAGE ##\n\nIn order to use this system, you have to implement several things in your\napplication.\n\n1.  Create a configuration class \n\t\n    Create add the following class in a django app\'s __init__.py, models.py or\n    some other location that is called when django first executes.  Define\n    "application_short_name" and "application_verbose_name" attributes.\n    \n    Implement the "get_default_configs()" method.  This must return a\n    configuration dictionary where the keys are the configuration variables for\n    the application, and the values are nested metadata dictionaries.\n    \n    Each nested dictionary must contain 3 keys:\n     - default = the default value that the key will take\n     - field = a django Field instance used to validate the value\n     - help (optional) = a help text entry that describes the key \n     - choices (optional) = a list of tuples constraining the input.  Only works\n       with fields that are like ChoiceField that take choices as part of the\n       constructor e.g., ((\'a_short_name\',\'A text\'),(\'b_short_name\', \'B text\'))\n    \n    You also need to register the config class with the "register()" method.\n    \n    See the example below:\n    \n    /path/to/myproject/myapp/__init__.py\n\t    \n        import site_config\n        \n        class FooSiteConfig(site_config.SiteConfigBase):\n        \n            application_short_name = "foo"\n            application_verbose_name = "Foo Application"\n            \n            # Optionally override if you want to customize the backend\n            # used for a given config.\n            def get_backend(self):\n                backend = getattr(settings, \'SITECONFIG_BACKEND_DEFAULT\',\n                    \'site_config.backends.model_backend.DatabaseBackend\')\n                return backend\n            \n            def get_default_configs(self):\n                return {\'TEST_A\':{\'default\':"Test A default", \n                                  \'field\':\'django.forms.CharField\', \n                                  \'help\':\'Test A help text.\'}, \n                        "TEST_B":{\'default\':1, \n                                  \'field\':\'django.forms.IntegerField\', \n                                  \'help\':\'Test B help text.\'}}\n        \n        site_config.registy.config_registry.register(MyAppSiteConfig)\n\n2.  Enable and disable urls via enable_disable_website() decorator\n    \n    In order to make use django_site_config\'s ability to enable and disable\n    particular views, you need to wrap your urls as follows.  In order to use\n    this website switching functionality, you need to pass in the "website"\n    kwarg as part of the url string.\n    \n    /path/to/myproject/myapp/urls.py\n\n        from django.conf.urls import include, url\n        from site_config.decorators import enable_disable_website, decorated_includes, website_template_override\n        from example.app_foo import FooConfig\n        from .views import IndexView\n        \n        # Wrap a single url \n        \n        urlpatterns = [\n           url(\'^(?P<website>[\\w-]+)/foo/$\', \n               enable_disable_website(IndexView.as_view(\n                   template_name=\'index.html\'), FooConfig), \n               {}, \n               name="app_foo_index"\n           )\n        ]\n        \n        # OR you can decorate an entire include\n\n        urlpatterns += decorated_includes(\n            lambda func: enable_disable_website(func, BarConfig),\n            website_template_override,\n            [url(r\'^(?P<website>[\\w-]+)/bar/\', include(\'example.app_bar.urls\'))]\n        )\n   \n   Note: You can also use this enable_disable_website() function to decorate a\n   django CBV or FBV according to the django documentation.\n   \n   Note: Your views must accept the \'website\' keyword argument. \n          \n3. Allow template overrides \n\n    This module also provides a means to override templates for a specific site.\n    \n    FOR FUNCTION-BASED VIEWS \n    \n    Normally, if a FBV defines a template_name parameter in the url, say\n    "index.html", the view will lookup that template file via the normal\n    template loader chain.\n    \n    However, the website_template_override() decorator will first try to lookup\n    a url at "[website]/index.html" and then fall back to using the\n    "index.html".\n\n    /path/to/myproject/myapp/urls.py\n    \n        # Wrap a single url \n        \n        urlpatterns = [\n            url(\'^(?P<website>[\\w-]+)/foo/$\', \n                website_template_override(IndexView.as_view(\n                template_name=\'index.html\')), \n                {}, \n                name="app_foo_index"\n            )\n        ]\n        \n        # OR you can decorate an entire include\n        \n        urlpatterns += decorated_includes(website_template_override,\n            [url(r\'^(?P<website>[\\w-]+)/bar/\', include(\'example.app_bar.urls\'))]\n        )\n\n        # OR you can use both decorators at once on an entire include.\n        urlpatterns += decorated_includes(\n            lambda func: enable_disable_website(func, BarConfig),\n            website_template_override,\n            [url(r\'^(?P<website>[\\w-]+)/bar/\', include(\'example.app_bar.urls\'))]\n        )\n     \n    You then need to accept the website variable as a keyword argument to your\n    view function.  The website variable can be used in your view logic.\n    \n    /path/to/myproject/myapp/views.py\n        \n        # Function based view example\n        def index(request, template_name, website=None, *args, **kwargs):\n            config = BarConfig(website=website)\n            return render_to_response(template_name,\n                {\'config\':config,},\n                context_instance=RequestContext(request))\n\n    FOR CLASS-BASED VIEWS\n    \n    You should use the WebsiteOverrideTemplateViewMixin to allow for the\n    template override behavior.\n    \n    /path/to/myproject/myapp/views.py\n        \n\t\tfrom site_config.utils import WebsiteOverrideTemplateViewMixin\n\t\tfrom site_config.decorators import website_template_override\n\t\tfrom example.app_bar import BarConfig\n\t\t\n\t\tclass IndexView(WebsiteOverrideTemplateViewMixin, TemplateView):\n\t\t    \n\t\t    def dispatch(self, request, *args, **kwargs):\n\t\t        self.website = kwargs.get(\'website\', None)\n\t\t        self.config = BarConfig(website=self.website)\n\t\t        return super().dispatch(request, *args, **kwargs)\n\t\t    \n\t\t    def get_context_data(self, **kwargs):\n\t\t        kwargs[\'config\'] = self.config\n\t\t        kwargs[\'website\'] = self.website\n\t\t        return kwargs\n        \n4.  You can access settings in the view or template by calling the settings like\n    you would an attribute on the config class.\n    \n    Here is a usage example:\n\n\t    from example.app_foo import FooConfig\n\t    c = FooConfig(website="joesite")\n\t    c.TEST_A\n\t    c.TEST_B\n\t    \n    Note: in order for the settings to be looked up dynamically (on each\n    request), the config class must be instantiated inside the view with the\n    proper website passed to the constructor (or None) on every request to the\n    view.\n\n\n## TEMPLATE OVERRIDES ##\n\nYou can override the template below to customize the curtain page that displays\nwhen a Website Application as marked as "curtained".  Note, the default template\nextends "base.html" so this will need to be present in your application.\n\n   site_config/curtained.html\n\n    \n## TESTING ##\n\n    pip install -e .[testing]\n    cd example/\n    ./manage.py test site_config\n\nNote: The tests in this version are out of date and need to be updated.\n',
    'author': 'Imagescape',
    'author_email': 'info@imagescape.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/ImaginaryLandscape/django_site_config',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
