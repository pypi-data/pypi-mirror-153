{"version":3,"file":"static/js/545.9f0aa1c6.chunk.js","mappings":"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","sources":["../../core/src/asset-graph/Utils.tsx","../../core/src/asset-graph/layout.ts"],"sourcesContent":["import {gql} from '@apollo/client';\nimport {pathVerticalDiagonal} from '@vx/shape';\nimport uniq from 'lodash/uniq';\n\nimport {AssetNodeDefinitionFragment} from '../assets/types/AssetNodeDefinitionFragment';\n\nimport {\n  AssetGraphLiveQuery_assetsLatestInfo,\n  AssetGraphLiveQuery_assetNodes_assetMaterializations,\n} from './types/AssetGraphLiveQuery';\nimport {\n  AssetGraphQuery_assetNodes,\n  AssetGraphQuery_assetNodes_assetKey,\n} from './types/AssetGraphQuery';\nimport {AssetNodeLiveFragment} from './types/AssetNodeLiveFragment';\nimport {\n  RepositoryLiveFragment,\n  RepositoryLiveFragment_latestRunByStep_run,\n} from './types/RepositoryLiveFragment';\ntype AssetNode = AssetGraphQuery_assetNodes;\ntype AssetKey = AssetGraphQuery_assetNodes_assetKey;\n\nexport const __ASSET_GROUP_PREFIX = '__ASSET_GROUP';\n\nexport function isAssetGroup(jobName: string) {\n  return jobName.startsWith(__ASSET_GROUP_PREFIX);\n}\n\n// IMPORTANT: We use this, rather than AssetNode.id throughout this file because\n// the GraphQL interface exposes dependencyKeys, not dependencyIds. We also need\n// ways to \"build\" GraphId's locally, they can't always be server-provided.\n//\n// This value is NOT the same as AssetNode.id values provided by the server,\n// because JSON.stringify's whitespace behavior is different than Python's.\n//\nexport type GraphId = string;\nexport const toGraphId = (key: AssetKey): GraphId => JSON.stringify(key.path);\n\nexport interface GraphNode {\n  id: GraphId;\n  assetKey: AssetKey;\n  definition: AssetNode;\n}\n\nexport interface GraphData {\n  nodes: {[assetId: GraphId]: GraphNode};\n  downstream: {[assetId: GraphId]: {[childAssetId: GraphId]: boolean}};\n  upstream: {[assetId: GraphId]: {[parentAssetId: GraphId]: boolean}};\n}\nexport const isSourceAsset = (node: {jobNames: string[]; opNames: string[]}) => {\n  return node.jobNames.length === 0 && !node.opNames.length;\n};\n\nexport function identifyBundles(assetIds: string[]) {\n  const pathPrefixes: {[prefixId: string]: string[]} = {};\n\n  for (const assetId of assetIds) {\n    const assetKeyPath = JSON.parse(assetId);\n\n    for (let ii = 1; ii < assetKeyPath.length; ii++) {\n      const prefix = assetKeyPath.slice(0, ii);\n      const key = JSON.stringify(prefix);\n      pathPrefixes[key] = pathPrefixes[key] || [];\n      pathPrefixes[key].push(assetId);\n    }\n  }\n\n  for (const key of Object.keys(pathPrefixes)) {\n    if (pathPrefixes[key].length <= 1) {\n      delete pathPrefixes[key];\n    }\n  }\n\n  const finalBundlePrefixes: {[prefixId: string]: string[]} = {};\n  const finalBundleIdForNodeId: {[id: string]: string} = {};\n\n  // Sort the prefix keys by length descending and iterate from the deepest folders first.\n  // Dedupe asset keys and replace asset keys we've already seen with the (deeper) folder\n  // they are within. This gets us \"multi layer folders\" of nodes.\n\n  // Turn this:\n  // {\n  //  \"s3\": [[\"s3\", \"collect\"], [\"s3\", \"prod\", \"a\"], [\"s3\", \"prod\", \"b\"]],\n  //  \"s3/prod\": [\"s3\", \"prod\", \"a\"], [\"s3\", \"prod\", \"b\"]\n  // }\n\n  // Into this:\n  // {\n  //  \"s3/prod\": [\"s3\", \"prod\", \"a\"], [\"s3\", \"prod\", \"b\"]\n  //  \"s3\": [[\"s3\", \"collect\"], [\"s3\", \"prod\"]],\n  // }\n\n  for (const prefixId of Object.keys(pathPrefixes).sort((a, b) => b.length - a.length)) {\n    const contents = uniq(\n      pathPrefixes[prefixId].map((p) =>\n        finalBundleIdForNodeId[p] ? finalBundleIdForNodeId[p] : p,\n      ),\n    );\n    if (contents.length === 1 && finalBundlePrefixes[contents[0]]) {\n      // If this bundle contains exactly one bundle, no need to show both outlines.\n      // Just show the inner one. eg: a > b > asset1, a > b > asset2, just show a > b.\n      continue;\n    }\n    finalBundlePrefixes[prefixId] = contents;\n    finalBundlePrefixes[prefixId].forEach((id) => (finalBundleIdForNodeId[id] = prefixId));\n  }\n  return finalBundlePrefixes;\n}\n\nexport const buildGraphData = (assetNodes: AssetNode[]) => {\n  const data: GraphData = {\n    nodes: {},\n    downstream: {},\n    upstream: {},\n  };\n\n  const addEdge = (upstreamGraphId: string, downstreamGraphId: string) => {\n    data.downstream[upstreamGraphId] = {\n      ...(data.downstream[upstreamGraphId] || {}),\n      [downstreamGraphId]: true,\n    };\n    data.upstream[downstreamGraphId] = {\n      ...(data.upstream[downstreamGraphId] || {}),\n      [upstreamGraphId]: true,\n    };\n  };\n\n  assetNodes.forEach((definition: AssetNode) => {\n    const id = toGraphId(definition.assetKey);\n    definition.dependencyKeys.forEach((key) => {\n      addEdge(toGraphId(key), id);\n    });\n    definition.dependedByKeys.forEach((key) => {\n      addEdge(id, toGraphId(key));\n    });\n\n    data.nodes[id] = {\n      id,\n      assetKey: definition.assetKey,\n      definition,\n    };\n  });\n\n  return data;\n};\n\nexport const buildGraphDataFromSingleNode = (assetNode: AssetNodeDefinitionFragment) => {\n  const id = toGraphId(assetNode.assetKey);\n  const graphData: GraphData = {\n    downstream: {\n      [id]: {},\n    },\n    nodes: {\n      [id]: {\n        id,\n        assetKey: assetNode.assetKey,\n        definition: {...assetNode, dependencyKeys: [], dependedByKeys: []},\n      },\n    },\n    upstream: {\n      [id]: {},\n    },\n  };\n\n  for (const {asset} of assetNode.dependencies) {\n    const depId = toGraphId(asset.assetKey);\n    graphData.upstream[id][depId] = true;\n    graphData.downstream[depId] = {...graphData.downstream[depId], [id]: true};\n    graphData.nodes[depId] = {\n      id: depId,\n      assetKey: asset.assetKey,\n      definition: {...asset, dependencyKeys: [], dependedByKeys: []},\n    };\n  }\n  for (const {asset} of assetNode.dependedBy) {\n    const depId = toGraphId(asset.assetKey);\n    graphData.upstream[depId] = {...graphData.upstream[depId], [id]: true};\n    graphData.downstream[id][depId] = true;\n    graphData.nodes[depId] = {\n      id: depId,\n      assetKey: asset.assetKey,\n      definition: {...asset, dependencyKeys: [], dependedByKeys: []},\n    };\n  }\n  return graphData;\n};\n\nexport const graphHasCycles = (graphData: GraphData) => {\n  const nodes = new Set(Object.keys(graphData.nodes));\n  const search = (stack: string[], node: string): boolean => {\n    if (stack.indexOf(node) !== -1) {\n      return true;\n    }\n    if (nodes.delete(node) === true) {\n      const nextStack = stack.concat(node);\n      return Object.keys(graphData.downstream[node] || {}).some((nextNode) =>\n        search(nextStack, nextNode),\n      );\n    }\n    return false;\n  };\n  let hasCycles = false;\n  while (nodes.size !== 0) {\n    hasCycles = hasCycles || search([], nodes.values().next().value);\n  }\n  return hasCycles;\n};\n\nexport const buildSVGPath = pathVerticalDiagonal({\n  source: (s: any) => s.source,\n  target: (s: any) => s.target,\n  x: (s: any) => s.x,\n  y: (s: any) => s.y,\n});\n\nexport type Status = 'good' | 'old' | 'none' | 'unknown';\n\nexport interface LiveDataForNode {\n  computeStatus: Status;\n  unstartedRunIds: string[]; // run in progress and step not started\n  inProgressRunIds: string[]; // run in progress and step in progress\n  runWhichFailedToMaterialize: RepositoryLiveFragment_latestRunByStep_run | null;\n  lastMaterialization: AssetGraphLiveQuery_assetNodes_assetMaterializations | null;\n  lastChanged: number;\n}\nexport interface LiveData {\n  [assetId: GraphId]: LiveDataForNode;\n}\n\nexport const buildLiveData = (\n  graph: GraphData,\n  nodes: AssetNodeLiveFragment[],\n  repos: RepositoryLiveFragment[],\n  assetsLatestInfo: AssetGraphLiveQuery_assetsLatestInfo[],\n) => {\n  const data: LiveData = {};\n\n  for (const liveNode of nodes) {\n    const graphId = toGraphId(liveNode.assetKey);\n    const graphNode = graph.nodes[graphId];\n    if (!graphNode) {\n      console.warn(`buildLiveData could not find the graph node matching ${graphId}`);\n      continue;\n    }\n    const lastMaterialization = liveNode.assetMaterializations[0] || null;\n    const lastChanged = Number(lastMaterialization?.timestamp || 0) / 1000;\n    const isPartitioned = graphNode.definition.partitionDefinition;\n    const repo = repos.find((r) => r.id === liveNode.repository.id);\n\n    const assetLiveRuns = assetsLatestInfo.find(\n      (r) => JSON.stringify(r.assetKey) === JSON.stringify(liveNode.assetKey),\n    );\n    const info = repo?.latestRunByStep.find((r) => liveNode.opNames.includes(r.stepKey));\n\n    const latestRunForStepKey = info?.__typename === 'LatestRun' ? info.run : null;\n\n    const runWhichFailedToMaterialize =\n      (latestRunForStepKey?.status === 'FAILURE' &&\n        (!lastMaterialization || lastMaterialization.runId !== latestRunForStepKey?.id) &&\n        latestRunForStepKey) ||\n      null;\n\n    data[graphId] = {\n      lastChanged,\n      lastMaterialization,\n      inProgressRunIds: assetLiveRuns?.inProgressRunIds || [],\n      unstartedRunIds: assetLiveRuns?.unstartedRunIds || [],\n      runWhichFailedToMaterialize,\n      computeStatus: isSourceAsset(graphNode.definition)\n        ? 'good' // foreign nodes are always considered up-to-date\n        : isPartitioned\n        ? // partitioned nodes are not supported, need to compare materializations\n          // of the same partition key and the API does not make fetching this easy\n          'none'\n        : lastMaterialization\n        ? 'unknown' // resolve to 'good' or 'old' by looking upstream\n        : 'none',\n    };\n  }\n\n  for (const liveNodeId of Object.keys(data)) {\n    data[liveNodeId].computeStatus = findComputeStatusForId(data, graph.upstream, liveNodeId);\n  }\n\n  return data;\n};\n\nfunction findComputeStatusForId(\n  data: LiveData,\n  upstream: {[assetId: string]: {[upstreamAssetId: string]: boolean}},\n  assetId: string,\n): Status {\n  if (!data[assetId]) {\n    // Currently compute status assumes foreign nodes are up to date\n    // and only shows \"upstream changed\" for upstreams in the same job\n    return 'good';\n  }\n  const ts = data[assetId].lastChanged;\n  const upstreamIds = Object.keys(upstream[assetId] || {});\n  if (data[assetId].computeStatus !== 'unknown') {\n    return data[assetId].computeStatus;\n  }\n\n  return upstreamIds.some((uid) => data[uid]?.lastChanged > ts)\n    ? 'old'\n    : upstreamIds.some((uid) => findComputeStatusForId(data, upstream, uid) !== 'good')\n    ? 'old'\n    : 'good';\n}\n\nexport function tokenForAssetKey(key: {path: string[]}) {\n  return key.path.join('/');\n}\n\nexport function displayNameForAssetKey(key: {path: string[]}) {\n  return key.path.join(' / ');\n}\n\nexport const LAST_RUNS_WARNINGS_FRAGMENT = gql`\n  fragment LastRunsWarningsFragment on LatestRun {\n    stepKey\n    run {\n      id\n      status\n    }\n  }\n`;\n\nexport const REPOSITORY_LIVE_FRAGMENT = gql`\n  fragment RepositoryLiveFragment on Repository {\n    id\n    name\n    location {\n      id\n      name\n    }\n    latestRunByStep {\n      __typename\n      ...LastRunsWarningsFragment\n    }\n  }\n  ${LAST_RUNS_WARNINGS_FRAGMENT}\n`;\n","import * as dagre from 'dagre';\n\nimport {IBounds, IPoint} from '../graph/common';\n\nimport {GraphData, GraphNode, GraphId, displayNameForAssetKey, identifyBundles} from './Utils';\n\nexport interface AssetLayout {\n  id: GraphId;\n\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n}\n\nexport type AssetLayoutEdge = {\n  from: IPoint;\n  fromId: string;\n  to: IPoint;\n  toId: string;\n};\n\nexport type AssetGraphLayout = {\n  width: number;\n  height: number;\n  edges: AssetLayoutEdge[];\n  nodes: {[id: string]: AssetLayout};\n\n  bundleEdges: AssetLayoutEdge[];\n  bundles: {[id: string]: AssetLayout};\n};\n\nconst opts: {margin: number; mini: boolean} = {\n  margin: 100,\n  mini: false,\n};\n\nexport const layoutAssetGraph = (graphData: GraphData): AssetGraphLayout => {\n  const g = new dagre.graphlib.Graph({compound: true});\n\n  g.setGraph({\n    rankdir: 'TB',\n    marginx: opts.margin,\n    marginy: opts.margin,\n    nodesep: opts.mini ? 20 : 50,\n    edgesep: opts.mini ? 10 : 10,\n    ranksep: opts.mini ? 20 : 50,\n  });\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const shouldRender = (node?: GraphNode) => node && node.definition.opNames.length > 0;\n\n  // Add all the nodes to the graph\n  Object.values(graphData.nodes)\n    .filter(shouldRender)\n    .forEach((node) => {\n      const {width, height} = getAssetNodeDimensions(node.definition);\n      g.setNode(node.id, {width: opts.mini ? 230 : width, height});\n    });\n\n  const foreignNodes = {};\n\n  // Add the edges to the graph, and accumulate a set of \"foreign nodes\" (for which\n  // we have an inbound/outbound edge, but we don't have the `node` in the graphData).\n  Object.keys(graphData.downstream).forEach((upstreamId) => {\n    const downstreamIds = Object.keys(graphData.downstream[upstreamId]);\n    downstreamIds.forEach((downstreamId) => {\n      if (\n        !shouldRender(graphData.nodes[downstreamId]) &&\n        !shouldRender(graphData.nodes[upstreamId])\n      ) {\n        return;\n      }\n\n      g.setEdge({v: upstreamId, w: downstreamId}, {weight: 1});\n\n      if (!shouldRender(graphData.nodes[downstreamId])) {\n        foreignNodes[downstreamId] = true;\n      } else if (!shouldRender(graphData.nodes[upstreamId])) {\n        foreignNodes[upstreamId] = true;\n      }\n    });\n  });\n\n  // Add all the foreign nodes to the graph\n  Object.keys(foreignNodes).forEach((id) => {\n    g.setNode(id, getForeignNodeDimensions(id));\n  });\n\n  // Create \"parent\" nodes for nodes with a shared ID (path) prefix (eg: s3>a, s3>b),\n  // and then place the children inside. Note that the bundles are identified in order\n  // and bundleMapping can reference bundles as children - this code can create multiple\n  // layers of parents!\n  const bundleMapping = identifyBundles(g.nodes());\n\n  for (const [parentId, nodeIds] of Object.entries(bundleMapping)) {\n    g.setNode(parentId, {});\n    for (const nodeId of nodeIds) {\n      g.setParent(nodeId, parentId);\n    }\n  }\n\n  dagre.layout(g);\n\n  const dagreNodesById: {[id: string]: dagre.Node} = {};\n  g.nodes().forEach((id) => {\n    const node = g.node(id);\n    if (!node) {\n      return;\n    }\n    dagreNodesById[id] = node;\n  });\n\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  const nodes: {[id: string]: AssetLayout} = {};\n  const bundles: {[id: string]: AssetLayout} = {};\n\n  Object.keys(dagreNodesById).forEach((id) => {\n    const dagreNode = dagreNodesById[id];\n    const bounds = {\n      x: dagreNode.x - dagreNode.width / 2,\n      y: dagreNode.y - dagreNode.height / 2,\n      width: dagreNode.width,\n      height: dagreNode.height,\n    };\n    if (bundleMapping[id]) {\n      return;\n    }\n    nodes[id] = {id, bounds};\n\n    // If this node was inside one or more parent nodes, upsert the parent box\n    // into the bundles result set and expand it to include the child. Note:\n    // dagre does give us \"parent\" node dimensions, but sometimes they're randomly\n    // much larger than the contents.\n    let bundleId = g.parent(id);\n    while (bundleId) {\n      bundles[bundleId] = bundles[bundleId] || {id: bundleId, bounds};\n      bundles[bundleId].bounds = extendBounds(bundles[bundleId].bounds, {\n        x: bounds.x - opts.margin / 4,\n        y: bounds.y - opts.margin / 4,\n        width: bounds.width + opts.margin / 2,\n        height: bounds.height + opts.margin / 2,\n      });\n      bundleId = g.parent(bundleId);\n    }\n    maxWidth = Math.max(maxWidth, dagreNode.x + dagreNode.width / 2);\n    maxHeight = Math.max(maxHeight, dagreNode.y + dagreNode.height / 2);\n  });\n\n  const edges: AssetLayoutEdge[] = [];\n  const bundleEdges: AssetLayoutEdge[] = [];\n\n  g.edges().forEach((e) => {\n    const points = g.edge(e).points;\n    if (bundles[e.v] || bundles[e.w]) {\n      bundleEdges.push({\n        from: points[0],\n        fromId: e.v,\n        to: points[points.length - 1],\n        toId: e.w,\n      });\n    } else {\n      edges.push({\n        from: points[0],\n        fromId: e.v,\n        to: points[points.length - 1],\n        toId: e.w,\n      });\n    }\n  });\n\n  return {\n    nodes,\n    edges,\n    bundles,\n    bundleEdges,\n    width: maxWidth + opts.margin,\n    height: maxHeight + opts.margin,\n  };\n};\n\nexport const getForeignNodeDimensions = (id: string) => {\n  const path = JSON.parse(id);\n  return {width: displayNameForAssetKey({path}).length * 8 + 30, height: 30};\n};\n\nexport const extendBounds = (a: IBounds, b: IBounds) => {\n  const xmin = Math.min(a.x, b.x);\n  const ymin = Math.min(a.y, b.y);\n  const xmax = Math.max(a.x + a.width, b.x + b.width);\n  const ymax = Math.max(a.y + a.height, b.y + b.height);\n  return {x: xmin, y: ymin, width: xmax - xmin, height: ymax - ymin};\n};\n\nexport const ASSET_NODE_ICON_WIDTH = 20;\nexport const ASSET_NODE_ANNOTATIONS_MAX_WIDTH = 65;\nexport const ASSET_NODE_NAME_MAX_LENGTH = 32;\nconst DISPLAY_NAME_PX_PER_CHAR = 8.0;\n\nexport const getAssetNodeDimensions = (def: {\n  assetKey: {path: string[]};\n  opNames: string[];\n  description?: string | null;\n}) => {\n  let height = 75;\n  if (def.description) {\n    height += 25;\n  }\n  const displayName = displayNameForAssetKey(def.assetKey);\n  const firstOp = def.opNames[0];\n  if (firstOp && displayName !== firstOp) {\n    height += 25;\n  }\n  return {\n    width:\n      Math.max(\n        200,\n        Math.min(ASSET_NODE_NAME_MAX_LENGTH, displayName.length) * DISPLAY_NAME_PX_PER_CHAR,\n      ) +\n      ASSET_NODE_ICON_WIDTH +\n      ASSET_NODE_ANNOTATIONS_MAX_WIDTH,\n    height,\n  };\n};\n"],"names":["identifyBundles","assetIds","pathPrefixes","assetId","assetKeyPath","JSON","parse","ii","length","prefix","slice","key","stringify","push","Object","keys","finalBundlePrefixes","finalBundleIdForNodeId","sort","a","b","prefixId","contents","uniq","map","p","forEach","id","pathVerticalDiagonal","source","s","target","x","y","displayNameForAssetKey","path","join","LAST_RUNS_WARNINGS_FRAGMENT","gql","opts","layoutAssetGraph","graphData","g","dagre","compound","setGraph","rankdir","marginx","marginy","nodesep","edgesep","ranksep","setDefaultEdgeLabel","shouldRender","node","definition","opNames","values","nodes","filter","getAssetNodeDimensions","width","height","setNode","foreignNodes","downstream","upstreamId","downstreamId","setEdge","v","w","weight","getForeignNodeDimensions","bundleMapping","entries","parentId","nodeIds","nodeId","setParent","dagreNodesById","maxWidth","maxHeight","bundles","dagreNode","bounds","bundleId","parent","extendBounds","Math","max","edges","bundleEdges","e","points","edge","from","fromId","to","toId","xmin","min","ymin","ASSET_NODE_ICON_WIDTH","ASSET_NODE_ANNOTATIONS_MAX_WIDTH","ASSET_NODE_NAME_MAX_LENGTH","def","description","displayName","assetKey","firstOp"],"sourceRoot":""}