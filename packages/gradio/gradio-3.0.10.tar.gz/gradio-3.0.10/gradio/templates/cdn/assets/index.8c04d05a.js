import{S as V,i as z,s as A,d as p,o as D,v as G,y as H,a6 as N,a7 as q,a8 as k,h as g,k as x,w as E,b as f,c as C,e as v,f as w,m as F,g as b,n as I,u as W,I as X,R as J,T as Y,B,C as P,D as j,E as S,F as R,K as Z,U as $,V as ee}from"./index.669f6a08.js";import{B as L}from"./Block.6132679d.js";import"./styles.d87a390f.js";const y="Users/aliabid/projects/gradio/ui/packages/chatbot/src/ChatBot.svelte";function K(s,e,t){const a=s.slice();return a[8]=e[t],a}function O(s){let e,t=s[8][0]+"",a,u,m,n,r=s[8][1]+"",l,o,d;const _={c:function(){e=g("div"),a=x(t),m=E(),n=g("div"),l=x(r),o=E(),f(e,"data-testid","user"),f(e,"class","px-3 py-2 rounded-[22px] rounded-br-none text-white ml-7 text-sm"),f(e,"style",u="background-color:"+s[2][0]),C(e,y,37,3,968),f(n,"data-testid","bot"),f(n,"class","px-3 py-2 rounded-[22px] rounded-bl-none place-self-start text-white ml-7 text-sm"),f(n,"style",d="background-color:"+s[2][1]),C(n,y,44,3,1153)},m:function(h,i){v(h,e,i),w(e,a),v(h,m,i),v(h,n,i),w(n,l),w(n,o)},p:function(h,i){i&1&&t!==(t=h[8][0]+"")&&F(a,t),i&4&&u!==(u="background-color:"+h[2][0])&&f(e,"style",u),i&1&&r!==(r=h[8][1]+"")&&F(l,r),i&4&&d!==(d="background-color:"+h[2][1])&&f(n,"style",d)},d:function(h){h&&b(e),h&&b(m),h&&b(n)}};return p("SvelteRegisterBlock",{block:_,id:O.name,type:"each",source:"(37:2) {#each value as message}",ctx:s}),_}function T(s){let e,t,a=s[0];D(a);let u=[];for(let n=0;n<a.length;n+=1)u[n]=O(K(s,a,n));const m={c:function(){e=g("div"),t=g("div");for(let r=0;r<u.length;r+=1)u[r].c();f(t,"class","flex flex-col items-end space-y-4 p-3"),C(t,y,35,1,886),f(e,"class","overflow-y-auto h-[40vh]"),C(e,y,34,0,830)},l:function(r){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(r,l){v(r,e,l),w(e,t);for(let o=0;o<u.length;o+=1)u[o].m(t,null);s[4](e)},p:function(r,[l]){if(l&5){a=r[0],D(a);let o;for(o=0;o<a.length;o+=1){const d=K(r,a,o);u[o]?u[o].p(d,l):(u[o]=O(d),u[o].c(),u[o].m(t,null))}for(;o<u.length;o+=1)u[o].d(1);u.length=a.length}},i:I,o:I,d:function(r){r&&b(e),W(u,r),s[4](null)}};return p("SvelteRegisterBlock",{block:m,id:T.name,type:"component",source:"",ctx:s}),m}function te(s,e,t){let a,{$$slots:u={},$$scope:m}=e;G("ChatBot",u,[]);let{value:n}=e,{color_map:r=void 0}=e,l,o;const d=H();N(()=>{o=l&&l.offsetHeight+l.scrollTop>l.scrollHeight-20}),q(()=>{o&&l.scrollTo(0,l.scrollHeight)});function _(){return r?r.map(i=>i in k?k[i].primary:i):["#fb923c","#9ca3af"]}const c=["value","color_map"];Object.keys(e).forEach(i=>{!~c.indexOf(i)&&i.slice(0,2)!=="$$"&&i!=="slot"&&console.warn(`<ChatBot> was created with unknown prop '${i}'`)});function h(i){X[i?"unshift":"push"](()=>{l=i,t(1,l)})}return s.$$set=i=>{"value"in i&&t(0,n=i.value),"color_map"in i&&t(3,r=i.color_map)},s.$capture_state=()=>({beforeUpdate:N,afterUpdate:q,createEventDispatcher:H,colors:k,value:n,color_map:r,div:l,autoscroll:o,dispatch:d,get_colors:_,_colors:a}),s.$inject_state=i=>{"value"in i&&t(0,n=i.value),"color_map"in i&&t(3,r=i.color_map),"div"in i&&t(1,l=i.div),"autoscroll"in i&&(o=i.autoscroll),"_colors"in i&&t(2,a=i._colors)},e&&"$$inject"in e&&s.$inject_state(e.$$inject),s.$$.update=()=>{s.$$.dirty&1&&n&&d("change")},t(2,a=_()),[n,l,a,r,h]}class M extends V{constructor(e){super(e),z(this,e,te,T,A,{value:0,color_map:3}),p("SvelteRegisterComponent",{component:this,tagName:"ChatBot",options:e,id:T.name});const{ctx:t}=this.$$,a=e.props||{};t[0]===void 0&&!("value"in a)&&console.warn("<ChatBot> was created without expected prop 'value'")}get value(){throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get color_map(){throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set color_map(e){throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function Q(s){let e,t,a,u;const m=[s[4]];let n={};for(let l=0;l<m.length;l+=1)n=Y(n,m[l]);e=new J({props:n,$$inline:!0}),a=new M({props:{value:s[2],color_map:s[3]},$$inline:!0}),a.$on("change",s[5]);const r={c:function(){B(e.$$.fragment),t=E(),B(a.$$.fragment)},m:function(o,d){P(e,o,d),v(o,t,d),P(a,o,d),u=!0},p:function(o,d){const _=d&16?$(m,[ee(o[4])]):{};e.$set(_);const c={};d&4&&(c.value=o[2]),d&8&&(c.color_map=o[3]),a.$set(c)},i:function(o){u||(j(e.$$.fragment,o),j(a.$$.fragment,o),u=!0)},o:function(o){S(e.$$.fragment,o),S(a.$$.fragment,o),u=!1},d:function(o){R(e,o),o&&b(t),R(a,o)}};return p("SvelteRegisterBlock",{block:r,id:Q.name,type:"slot",source:"(11:0) <Block padding={false} {elem_id} {visible}>",ctx:s}),r}function U(s){let e,t;e=new L({props:{padding:!1,elem_id:s[0],visible:s[1],$$slots:{default:[Q]},$$scope:{ctx:s}},$$inline:!0});const a={c:function(){B(e.$$.fragment)},l:function(m){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(m,n){P(e,m,n),t=!0},p:function(m,[n]){const r={};n&1&&(r.elem_id=m[0]),n&2&&(r.visible=m[1]),n&92&&(r.$$scope={dirty:n,ctx:m}),e.$set(r)},i:function(m){t||(j(e.$$.fragment,m),t=!0)},o:function(m){S(e.$$.fragment,m),t=!1},d:function(m){R(e,m)}};return p("SvelteRegisterBlock",{block:a,id:U.name,type:"component",source:"",ctx:s}),a}function oe(s,e,t){let{$$slots:a={},$$scope:u}=e;G("Chatbot",a,[]);let{elem_id:m=""}=e,{visible:n=!0}=e,{value:r=[]}=e,{color_map:l}=e,{loading_status:o}=e;const d=["elem_id","visible","value","color_map","loading_status"];Object.keys(e).forEach(c=>{!~d.indexOf(c)&&c.slice(0,2)!=="$$"&&c!=="slot"&&console.warn(`<Chatbot> was created with unknown prop '${c}'`)});function _(c){Z.call(this,s,c)}return s.$$set=c=>{"elem_id"in c&&t(0,m=c.elem_id),"visible"in c&&t(1,n=c.visible),"value"in c&&t(2,r=c.value),"color_map"in c&&t(3,l=c.color_map),"loading_status"in c&&t(4,o=c.loading_status)},s.$capture_state=()=>({ChatBot:M,Block:L,StatusTracker:J,elem_id:m,visible:n,value:r,color_map:l,loading_status:o}),s.$inject_state=c=>{"elem_id"in c&&t(0,m=c.elem_id),"visible"in c&&t(1,n=c.visible),"value"in c&&t(2,r=c.value),"color_map"in c&&t(3,l=c.color_map),"loading_status"in c&&t(4,o=c.loading_status)},e&&"$$inject"in e&&s.$inject_state(e.$$inject),[m,n,r,l,o,_]}class ne extends V{constructor(e){super(e),z(this,e,oe,U,A,{elem_id:0,visible:1,value:2,color_map:3,loading_status:4}),p("SvelteRegisterComponent",{component:this,tagName:"Chatbot",options:e,id:U.name});const{ctx:t}=this.$$,a=e.props||{};t[3]===void 0&&!("color_map"in a)&&console.warn("<Chatbot> was created without expected prop 'color_map'"),t[4]===void 0&&!("loading_status"in a)&&console.warn("<Chatbot> was created without expected prop 'loading_status'")}get elem_id(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get color_map(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set color_map(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get loading_status(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set loading_status(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var re=ne;const ie=["static"];export{re as Component,ie as modes};
