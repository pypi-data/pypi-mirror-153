import{S as B,i as p,s as E,d,Z as D,v as P,h as N,b as w,t as y,c as q,e as k,l as F,_ as K,$ as Q,a0 as U,D as j,E as z,g as S,K as C,P as X,X as v,Q as Z,B as A,C as G,F as H,k as I,m as J}from"./index.32048461.js";import{c as _}from"./styles.d87a390f.js";const L="Users/aliabid/projects/gradio/ui/packages/button/src/Button.svelte";function b(n){let e,t,a,u,o;const c=n[6].default,r=D(c,n,n[5],null),f={c:function(){e=N("button"),r&&r.c(),w(e,"class",t=`gr-button gr-button-${n[4]} gr-button-${n[3]} self-start`+_(n[0])),w(e,"id",n[1]),y(e,"hidden",n[2]===!1),q(e,L,8,0,208)},l:function(l){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(l,h){k(l,e,h),r&&r.m(e,null),a=!0,u||(o=F(e,"click",n[7],!1,!1,!1),u=!0)},p:function(l,[h]){r&&r.p&&(!a||h&32)&&K(r,c,l,l[5],a?U(c,l[5],h,null):Q(l[5]),null),(!a||h&25&&t!==(t=`gr-button gr-button-${l[4]} gr-button-${l[3]} self-start`+_(l[0])))&&w(e,"class",t),(!a||h&2)&&w(e,"id",l[1]),h&29&&y(e,"hidden",l[2]===!1)},i:function(l){a||(j(r,l),a=!0)},o:function(l){z(r,l),a=!1},d:function(l){l&&S(e),r&&r.d(l),u=!1,o()}};return d("SvelteRegisterBlock",{block:f,id:b.name,type:"component",source:"",ctx:n}),f}function M(n,e,t){let{$$slots:a={},$$scope:u}=e;P("Button",a,["default"]);let{style:o={}}=e,{elem_id:c=""}=e,{visible:r=!0}=e,{variant:f="secondary"}=e,{size:m="lg"}=e;const l=["style","elem_id","visible","variant","size"];Object.keys(e).forEach(s=>{!~l.indexOf(s)&&s.slice(0,2)!=="$$"&&s!=="slot"&&console.warn(`<Button> was created with unknown prop '${s}'`)});function h(s){C.call(this,n,s)}return n.$$set=s=>{"style"in s&&t(0,o=s.style),"elem_id"in s&&t(1,c=s.elem_id),"visible"in s&&t(2,r=s.visible),"variant"in s&&t(3,f=s.variant),"size"in s&&t(4,m=s.size),"$$scope"in s&&t(5,u=s.$$scope)},n.$capture_state=()=>({create_classes:_,style:o,elem_id:c,visible:r,variant:f,size:m}),n.$inject_state=s=>{"style"in s&&t(0,o=s.style),"elem_id"in s&&t(1,c=s.elem_id),"visible"in s&&t(2,r=s.visible),"variant"in s&&t(3,f=s.variant),"size"in s&&t(4,m=s.size)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),[o,c,r,f,m,u,a,h]}class R extends B{constructor(e){super(e),p(this,e,M,b,E,{style:0,elem_id:1,visible:2,variant:3,size:4}),d("SvelteRegisterComponent",{component:this,tagName:"Button",options:e,id:b.name})}get style(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set style(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get variant(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set variant(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get size(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set size(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function O(n){let e=n[5](n[3])+"",t;const a={c:function(){t=I(e)},m:function(o,c){k(o,t,c)},p:function(o,c){c&40&&e!==(e=o[5](o[3])+"")&&J(t,e)},d:function(o){o&&S(t)}};return d("SvelteRegisterBlock",{block:a,id:O.name,type:"slot",source:"(10:0) <Button {variant} {elem_id} {visible} {style} on:click>",ctx:n}),a}function g(n){let e,t;e=new R({props:{variant:n[4],elem_id:n[1],visible:n[2],style:n[0],$$slots:{default:[O]},$$scope:{ctx:n}},$$inline:!0}),e.$on("click",n[6]);const a={c:function(){A(e.$$.fragment)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,c){G(e,o,c),t=!0},p:function(o,[c]){const r={};c&16&&(r.variant=o[4]),c&2&&(r.elem_id=o[1]),c&4&&(r.visible=o[2]),c&1&&(r.style=o[0]),c&168&&(r.$$scope={dirty:c,ctx:o}),e.$set(r)},i:function(o){t||(j(e.$$.fragment,o),t=!0)},o:function(o){z(e.$$.fragment,o),t=!1},d:function(o){H(e,o)}};return d("SvelteRegisterBlock",{block:a,id:g.name,type:"component",source:"",ctx:n}),a}function T(n,e,t){let a;X(v,"_"),Z(n,v,i=>t(5,a=i));let{$$slots:u={},$$scope:o}=e;P("Button",u,[]);let{style:c={}}=e,{elem_id:r=""}=e,{visible:f=!0}=e,{value:m}=e,{variant:l="primary"}=e;const h=["style","elem_id","visible","value","variant"];Object.keys(e).forEach(i=>{!~h.indexOf(i)&&i.slice(0,2)!=="$$"&&i!=="slot"&&console.warn(`<Button> was created with unknown prop '${i}'`)});function s(i){C.call(this,n,i)}return n.$$set=i=>{"style"in i&&t(0,c=i.style),"elem_id"in i&&t(1,r=i.elem_id),"visible"in i&&t(2,f=i.visible),"value"in i&&t(3,m=i.value),"variant"in i&&t(4,l=i.variant)},n.$capture_state=()=>({Button:R,_:v,style:c,elem_id:r,visible:f,value:m,variant:l,$_:a}),n.$inject_state=i=>{"style"in i&&t(0,c=i.style),"elem_id"in i&&t(1,r=i.elem_id),"visible"in i&&t(2,f=i.visible),"value"in i&&t(3,m=i.value),"variant"in i&&t(4,l=i.variant)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),[c,r,f,m,l,a,s]}class V extends B{constructor(e){super(e),p(this,e,T,g,E,{style:0,elem_id:1,visible:2,value:3,variant:4}),d("SvelteRegisterComponent",{component:this,tagName:"Button_1",options:e,id:g.name});const{ctx:t}=this.$$,a=e.props||{};t[3]===void 0&&!("value"in a)&&console.warn("<Button> was created without expected prop 'value'")}get style(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set style(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get variant(){throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set variant(e){throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var x=V;const $=["static"];export{x as Component,$ as modes};
