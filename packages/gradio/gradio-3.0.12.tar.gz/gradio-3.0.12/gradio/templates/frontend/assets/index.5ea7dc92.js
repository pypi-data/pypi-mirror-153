import{S as I,i as L,s as q,d as _,v as A,a as O,b as m,c as g,e as v,f as k,n as E,g as y,o as F,y as G,a7 as K,a8 as Y,a9 as U,h as B,k as Z,w as P,m as J,u as oe,I as ne,R as W,x as se,T as le,B as j,C as S,D as p,E as C,F as R,K as ae,U as re,V as ce,G as ie,H as ue}from"./index.970aa941.js";import{B as X}from"./Block.359d42ba.js";import{B as x}from"./BlockLabel.791af600.js";import"./styles.db46e346.js";const M="Users/aliabid/projects/gradio/ui/packages/icons/src/Chat.svelte";function N(n){let e,o,i;const a={c:function(){e=O("svg"),o=O("path"),i=O("path"),m(o,"fill","currentColor"),m(o,"d","M17.74 30L16 29l4-7h6a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h9v2H6a4 4 0 0 1-4-4V8a4 4 0 0 1 4-4h20a4 4 0 0 1 4 4v12a4 4 0 0 1-4 4h-4.84Z"),g(o,M,10,2,239),m(i,"fill","currentColor"),m(i,"d","M8 10h16v2H8zm0 6h10v2H8z"),g(i,M,13,3,438),m(e,"xmlns","http://www.w3.org/2000/svg"),m(e,"xmlns:xlink","http://www.w3.org/1999/xlink"),m(e,"aria-hidden","true"),m(e,"role","img"),m(e,"class","iconify iconify--carbon"),m(e,"width","100%"),m(e,"height","100%"),m(e,"preserveAspectRatio","xMidYMid meet"),m(e,"viewBox","0 0 32 32"),g(e,M,0,0,0)},l:function(s){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,r){v(s,e,r),k(e,o),k(e,i)},p:E,i:E,o:E,d:function(s){s&&y(e)}};return _("SvelteRegisterBlock",{block:a,id:N.name,type:"component",source:"",ctx:n}),a}function he(n,e){let{$$slots:o={},$$scope:i}=e;A("Chat",o,[]);const a=[];return Object.keys(e).forEach(l=>{!~a.indexOf(l)&&l.slice(0,2)!=="$$"&&l!=="slot"&&console.warn(`<Chat> was created with unknown prop '${l}'`)}),[]}class $ extends I{constructor(e){super(e),L(this,e,he,N,q,{}),_("SvelteRegisterComponent",{component:this,tagName:"Chat",options:e,id:N.name})}}const H="Users/aliabid/projects/gradio/ui/packages/chatbot/src/ChatBot.svelte";function Q(n,e,o){const i=n.slice();return i[9]=e[o],i}function T(n){let e,o=n[9][0]+"",i,a,l,s,r=n[9][1]+"",c,h,f;const u={c:function(){e=B("div"),i=Z(o),l=P(),s=B("div"),c=Z(r),h=P(),m(e,"data-testid","user"),m(e,"class","px-3 py-2 rounded-[22px] rounded-br-none text-white text-sm"),m(e,"style",a="background-color:"+n[2][0]),g(e,H,38,3,973),m(s,"data-testid","bot"),m(s,"class","px-3 py-2 rounded-[22px] rounded-bl-none place-self-start text-whitetext-sm"),m(s,"style",f="background-color:"+n[2][1]),g(s,H,45,3,1153)},m:function(b,w){v(b,e,w),k(e,i),v(b,l,w),v(b,s,w),k(s,c),k(s,h)},p:function(b,w){w&1&&o!==(o=b[9][0]+"")&&J(i,o),w&4&&a!==(a="background-color:"+b[2][0])&&m(e,"style",a),w&1&&r!==(r=b[9][1]+"")&&J(c,r),w&4&&f!==(f="background-color:"+b[2][1])&&m(s,"style",f)},d:function(b){b&&y(e),b&&y(l),b&&y(s)}};return _("SvelteRegisterBlock",{block:u,id:T.name,type:"each",source:"(38:2) {#each value as message}",ctx:n}),u}function D(n){let e,o,i=n[0];F(i);let a=[];for(let s=0;s<i.length;s+=1)a[s]=T(Q(n,i,s));const l={c:function(){e=B("div"),o=B("div");for(let r=0;r<a.length;r+=1)a[r].c();m(o,"class","flex flex-col items-end space-y-4 p-3"),g(o,H,36,1,891),m(e,"class","overflow-y-auto h-[40vh]"),g(e,H,35,0,835)},l:function(r){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(r,c){v(r,e,c),k(e,o);for(let h=0;h<a.length;h+=1)a[h].m(o,null);n[4](e)},p:function(r,[c]){if(c&5){i=r[0],F(i);let h;for(h=0;h<i.length;h+=1){const f=Q(r,i,h);a[h]?a[h].p(f,c):(a[h]=T(f),a[h].c(),a[h].m(o,null))}for(;h<a.length;h+=1)a[h].d(1);a.length=i.length}},i:E,o:E,d:function(r){r&&y(e),oe(a,r),n[4](null)}};return _("SvelteRegisterBlock",{block:l,id:D.name,type:"component",source:"",ctx:n}),l}function fe(n,e,o){let i,{$$slots:a={},$$scope:l}=e;A("ChatBot",a,[]);let{value:s}=e,{style:r={}}=e,c,h;const f=G();K(()=>{h=c&&c.offsetHeight+c.scrollTop>c.scrollHeight-20}),Y(()=>{h&&c.scrollTo(0,c.scrollHeight)});function u(t){return t in U?U[t].primary:t}function d(){return r.color_map?[u(r.color_map.bot),u(r.color_map.user)]:["#fb923c","#9ca3af"]}const b=["value","style"];Object.keys(e).forEach(t=>{!~b.indexOf(t)&&t.slice(0,2)!=="$$"&&t!=="slot"&&console.warn(`<ChatBot> was created with unknown prop '${t}'`)});function w(t){ne[t?"unshift":"push"](()=>{c=t,o(1,c)})}return n.$$set=t=>{"value"in t&&o(0,s=t.value),"style"in t&&o(3,r=t.style)},n.$capture_state=()=>({beforeUpdate:K,afterUpdate:Y,createEventDispatcher:G,colors:U,value:s,style:r,div:c,autoscroll:h,dispatch:f,get_color:u,get_colors:d,_colors:i}),n.$inject_state=t=>{"value"in t&&o(0,s=t.value),"style"in t&&o(3,r=t.style),"div"in t&&o(1,c=t.div),"autoscroll"in t&&(h=t.autoscroll),"_colors"in t&&o(2,i=t._colors)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&1&&s&&f("change")},o(2,i=d()),[s,c,i,r,w]}class ee extends I{constructor(e){super(e),L(this,e,fe,D,q,{value:0,style:3}),_("SvelteRegisterComponent",{component:this,tagName:"ChatBot",options:e,id:D.name});const{ctx:o}=this.$$,i=e.props||{};o[0]===void 0&&!("value"in i)&&console.warn("<ChatBot> was created without expected prop 'value'")}get value(){throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get style(){throw new Error("<ChatBot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set style(e){throw new Error("<ChatBot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const{Object:de}=se;function V(n){let e,o;e=new x({props:{show_label:n[5],Icon:$,label:n[4]||"Chatbot",disable:typeof n[0].container=="boolean"&&!n[0].container},$$inline:!0});const i={c:function(){j(e.$$.fragment)},m:function(l,s){S(e,l,s),o=!0},p:function(l,s){const r={};s&32&&(r.show_label=l[5]),s&16&&(r.label=l[4]||"Chatbot"),s&1&&(r.disable=typeof l[0].container=="boolean"&&!l[0].container),e.$set(r)},i:function(l){o||(p(e.$$.fragment,l),o=!0)},o:function(l){C(e.$$.fragment,l),o=!1},d:function(l){R(e,l)}};return _("SvelteRegisterBlock",{block:i,id:V.name,type:"if",source:"(20:1) {#if show_label}",ctx:n}),i}function te(n){let e,o,i,a,l;const s=[n[6]];let r={};for(let f=0;f<s.length;f+=1)r=le(r,s[f]);e=new W({props:r,$$inline:!0});let c=n[5]&&V(n);a=new ee({props:{style:n[0],value:n[3]},$$inline:!0}),a.$on("change",n[8]);const h={c:function(){j(e.$$.fragment),o=P(),c&&c.c(),i=P(),j(a.$$.fragment)},m:function(u,d){S(e,u,d),v(u,o,d),c&&c.m(u,d),v(u,i,d),S(a,u,d),l=!0},p:function(u,d){const b=d&64?re(s,[ce(u[6])]):{};e.$set(b),u[5]?c?(c.p(u,d),d&32&&p(c,1)):(c=V(u),c.c(),p(c,1),c.m(i.parentNode,i)):c&&(ie(),C(c,1,1,()=>{c=null}),ue());const w={};d&1&&(w.style=u[0]),d&8&&(w.value=u[3]),a.$set(w)},i:function(u){l||(p(e.$$.fragment,u),p(c),p(a.$$.fragment,u),l=!0)},o:function(u){C(e.$$.fragment,u),C(c),C(a.$$.fragment,u),l=!1},d:function(u){R(e,u),u&&y(o),c&&c.d(u),u&&y(i),R(a,u)}};return _("SvelteRegisterBlock",{block:h,id:te.name,type:"slot",source:"(18:0) <Block padding={false} {elem_id} style={{ rounded: style.rounded }} {visible}>",ctx:n}),h}function z(n){let e,o;e=new X({props:{padding:!1,elem_id:n[1],style:{rounded:n[0].rounded},visible:n[2],$$slots:{default:[te]},$$scope:{ctx:n}},$$inline:!0});const i={c:function(){j(e.$$.fragment)},l:function(l){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(l,s){S(e,l,s),o=!0},p:function(l,[s]){const r={};s&2&&(r.elem_id=l[1]),s&1&&(r.style={rounded:l[0].rounded}),s&4&&(r.visible=l[2]),s&633&&(r.$$scope={dirty:s,ctx:l}),e.$set(r)},i:function(l){o||(p(e.$$.fragment,l),o=!0)},o:function(l){C(e.$$.fragment,l),o=!1},d:function(l){R(e,l)}};return _("SvelteRegisterBlock",{block:i,id:z.name,type:"component",source:"",ctx:n}),i}function me(n,e,o){let{$$slots:i={},$$scope:a}=e;A("Chatbot",i,[]);let{elem_id:l=""}=e,{visible:s=!0}=e,{value:r=[]}=e,{style:c={}}=e,{label:h}=e,{show_label:f=!0}=e,{color_map:u={}}=e,{loading_status:d}=e;const b=["elem_id","visible","value","style","label","show_label","color_map","loading_status"];de.keys(e).forEach(t=>{!~b.indexOf(t)&&t.slice(0,2)!=="$$"&&t!=="slot"&&console.warn(`<Chatbot> was created with unknown prop '${t}'`)});function w(t){ae.call(this,n,t)}return n.$$set=t=>{"elem_id"in t&&o(1,l=t.elem_id),"visible"in t&&o(2,s=t.visible),"value"in t&&o(3,r=t.value),"style"in t&&o(0,c=t.style),"label"in t&&o(4,h=t.label),"show_label"in t&&o(5,f=t.show_label),"color_map"in t&&o(7,u=t.color_map),"loading_status"in t&&o(6,d=t.loading_status)},n.$capture_state=()=>({ChatBot:ee,Block:X,BlockLabel:x,StatusTracker:W,Chat:$,elem_id:l,visible:s,value:r,style:c,label:h,show_label:f,color_map:u,loading_status:d}),n.$inject_state=t=>{"elem_id"in t&&o(1,l=t.elem_id),"visible"in t&&o(2,s=t.visible),"value"in t&&o(3,r=t.value),"style"in t&&o(0,c=t.style),"label"in t&&o(4,h=t.label),"show_label"in t&&o(5,f=t.show_label),"color_map"in t&&o(7,u=t.color_map),"loading_status"in t&&o(6,d=t.loading_status)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&129&&!c.color_map&&Object.keys(u).length&&o(0,c.color_map=u,c)},[c,l,s,r,h,f,d,u,w]}class be extends I{constructor(e){super(e),L(this,e,me,z,q,{elem_id:1,visible:2,value:3,style:0,label:4,show_label:5,color_map:7,loading_status:6}),_("SvelteRegisterComponent",{component:this,tagName:"Chatbot",options:e,id:z.name});const{ctx:o}=this.$$,i=e.props||{};o[4]===void 0&&!("label"in i)&&console.warn("<Chatbot> was created without expected prop 'label'"),o[6]===void 0&&!("loading_status"in i)&&console.warn("<Chatbot> was created without expected prop 'loading_status'")}get elem_id(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get style(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set style(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get show_label(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set show_label(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get color_map(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set color_map(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get loading_status(){throw new Error("<Chatbot>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set loading_status(e){throw new Error("<Chatbot>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var ve=be;const ye=["static"];export{ve as Component,ye as modes};
