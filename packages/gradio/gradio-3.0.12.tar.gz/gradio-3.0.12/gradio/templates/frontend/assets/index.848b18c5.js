import{S as g,i as p,s as k,d as m,v as M,y as w,h as P,b as h,a3 as j,t as b,c as S,e as C,n as _,g as O,B as R,C as B,D,E as H,F as L,K as N}from"./index.970aa941.js";const T="Users/aliabid/projects/gradio/ui/packages/markdown/src/Markdown.svelte";function v(n){let e;const o={c:function(){e=P("div"),h(e,"id",n[0]),h(e,"class","output-markdown gr-prose"),j(e,"max-width","100%"),b(e,"hidden",n[1]===!1),S(e,T,9,0,246)},l:function(r){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(r,t){C(r,e,t),e.innerHTML=n[2]},p:function(r,[t]){t&4&&(e.innerHTML=r[2]),t&1&&h(e,"id",r[0]),t&2&&b(e,"hidden",r[1]===!1)},i:_,o:_,d:function(r){r&&O(e)}};return m("SvelteRegisterBlock",{block:o,id:v.name,type:"component",source:"",ctx:n}),o}function q(n,e,o){let{$$slots:c={},$$scope:r}=e;M("Markdown",c,[]);let{elem_id:t=""}=e,{visible:a=!0}=e,{value:l}=e;const d=w(),u=["elem_id","visible","value"];return Object.keys(e).forEach(i=>{!~u.indexOf(i)&&i.slice(0,2)!=="$$"&&i!=="slot"&&console.warn(`<Markdown> was created with unknown prop '${i}'`)}),n.$$set=i=>{"elem_id"in i&&o(0,t=i.elem_id),"visible"in i&&o(1,a=i.visible),"value"in i&&o(2,l=i.value)},n.$capture_state=()=>({createEventDispatcher:w,elem_id:t,visible:a,value:l,dispatch:d}),n.$inject_state=i=>{"elem_id"in i&&o(0,t=i.elem_id),"visible"in i&&o(1,a=i.visible),"value"in i&&o(2,l=i.value)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&4&&d("change")},[t,a,l]}class y extends g{constructor(e){super(e),p(this,e,q,v,k,{elem_id:0,visible:1,value:2}),m("SvelteRegisterComponent",{component:this,tagName:"Markdown",options:e,id:v.name});const{ctx:o}=this.$$,c=e.props||{};o[2]===void 0&&!("value"in c)&&console.warn("<Markdown> was created without expected prop 'value'")}get elem_id(){throw new Error("<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function f(n){let e,o;e=new y({props:{value:n[2],elem_id:n[0],visible:n[1]},$$inline:!0}),e.$on("change",n[4]);const c={c:function(){R(e.$$.fragment)},l:function(t){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(t,a){B(e,t,a),o=!0},p:function(t,[a]){const l={};a&4&&(l.value=t[2]),a&1&&(l.elem_id=t[0]),a&2&&(l.visible=t[1]),e.$set(l)},i:function(t){o||(D(e.$$.fragment,t),o=!0)},o:function(t){H(e.$$.fragment,t),o=!1},d:function(t){L(e,t)}};return m("SvelteRegisterBlock",{block:c,id:f.name,type:"component",source:"",ctx:n}),c}function F(n,e,o){let{$$slots:c={},$$scope:r}=e;M("Markdown",c,[]);let{label:t}=e,{elem_id:a=""}=e,{visible:l=!0}=e,{value:d=""}=e;const u=w(),i=["label","elem_id","visible","value"];Object.keys(e).forEach(s=>{!~i.indexOf(s)&&s.slice(0,2)!=="$$"&&s!=="slot"&&console.warn(`<Markdown> was created with unknown prop '${s}'`)});function E(s){N.call(this,n,s)}return n.$$set=s=>{"label"in s&&o(3,t=s.label),"elem_id"in s&&o(0,a=s.elem_id),"visible"in s&&o(1,l=s.visible),"value"in s&&o(2,d=s.value)},n.$capture_state=()=>({createEventDispatcher:w,Markdown:y,label:t,elem_id:a,visible:l,value:d,dispatch:u}),n.$inject_state=s=>{"label"in s&&o(3,t=s.label),"elem_id"in s&&o(0,a=s.elem_id),"visible"in s&&o(1,l=s.visible),"value"in s&&o(2,d=s.value)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&8&&u("change")},[a,l,d,t,E]}class K extends g{constructor(e){super(e),p(this,e,F,f,k,{label:3,elem_id:0,visible:1,value:2}),m("SvelteRegisterComponent",{component:this,tagName:"Markdown_1",options:e,id:f.name});const{ctx:o}=this.$$,c=e.props||{};o[3]===void 0&&!("label"in c)&&console.warn("<Markdown> was created without expected prop 'label'")}get label(){throw new Error("<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Markdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Markdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var z=K;const A=["static"];export{z as Component,A as modes};
