import{S as E,i as y,s as j,d as g,v as P,R as p,T as S,Z as R,B as h,C as w,D as d,E as m,F as b,K as B,w as D,e as O,U as T,V as q,_ as F,$ as K,a0 as N,g as U}from"./index.075cb19a.js";import{C as v}from"./CarouselItem.svelte_svelte_type_style_lang.05ac6f47.js";function C(o){let t,i,r;const l=[o[2]];let s={};for(let c=0;c<l.length;c+=1)s=S(s,l[c]);t=new p({props:s,$$inline:!0});const a=o[3].default,n=R(a,o,o[5],null),_={c:function(){h(t.$$.fragment),i=D(),n&&n.c()},m:function(e,u){w(t,e,u),O(e,i,u),n&&n.m(e,u),r=!0},p:function(e,u){const k=u&4?T(l,[q(e[2])]):{};t.$set(k),n&&n.p&&(!r||u&32)&&F(n,a,e,e[5],r?N(a,e[5],u,null):K(e[5]),null)},i:function(e){r||(d(t.$$.fragment,e),d(n,e),r=!0)},o:function(e){m(t.$$.fragment,e),m(n,e),r=!1},d:function(e){b(t,e),e&&U(i),n&&n.d(e)}};return g("SvelteRegisterBlock",{block:_,id:C.name,type:"slot",source:"(8:0) <Carousel {elem_id} {visible} on:change>",ctx:o}),_}function f(o){let t,i;t=new v({props:{elem_id:o[0],visible:o[1],$$slots:{default:[C]},$$scope:{ctx:o}},$$inline:!0}),t.$on("change",o[4]);const r={c:function(){h(t.$$.fragment)},l:function(s){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,a){w(t,s,a),i=!0},p:function(s,[a]){const n={};a&1&&(n.elem_id=s[0]),a&2&&(n.visible=s[1]),a&36&&(n.$$scope={dirty:a,ctx:s}),t.$set(n)},i:function(s){i||(d(t.$$.fragment,s),i=!0)},o:function(s){m(t.$$.fragment,s),i=!1},d:function(s){b(t,s)}};return g("SvelteRegisterBlock",{block:r,id:f.name,type:"component",source:"",ctx:o}),r}function V(o,t,i){let{$$slots:r={},$$scope:l}=t;P("Carousel",r,["default"]);let{elem_id:s=""}=t,{visible:a=!0}=t,{loading_status:n}=t;const _=["elem_id","visible","loading_status"];Object.keys(t).forEach(e=>{!~_.indexOf(e)&&e.slice(0,2)!=="$$"&&e!=="slot"&&console.warn(`<Carousel> was created with unknown prop '${e}'`)});function c(e){B.call(this,o,e)}return o.$$set=e=>{"elem_id"in e&&i(0,s=e.elem_id),"visible"in e&&i(1,a=e.visible),"loading_status"in e&&i(2,n=e.loading_status),"$$scope"in e&&i(5,l=e.$$scope)},o.$capture_state=()=>({Carousel:v,StatusTracker:p,elem_id:s,visible:a,loading_status:n}),o.$inject_state=e=>{"elem_id"in e&&i(0,s=e.elem_id),"visible"in e&&i(1,a=e.visible),"loading_status"in e&&i(2,n=e.loading_status)},t&&"$$inject"in t&&o.$inject_state(t.$$inject),[s,a,n,r,c,l]}class Z extends E{constructor(t){super(t),y(this,t,V,f,j,{elem_id:0,visible:1,loading_status:2}),g("SvelteRegisterComponent",{component:this,tagName:"Carousel_1",options:t,id:f.name});const{ctx:i}=this.$$,r=t.props||{};i[2]===void 0&&!("loading_status"in r)&&console.warn("<Carousel> was created without expected prop 'loading_status'")}get elem_id(){throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(t){throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(t){throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get loading_status(){throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set loading_status(t){throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var G=Z;const H=["static"];export{G as Component,H as modes};
