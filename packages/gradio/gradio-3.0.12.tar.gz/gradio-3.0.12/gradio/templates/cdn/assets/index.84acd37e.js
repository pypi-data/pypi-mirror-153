import{S as g,i as p,s as H,d as h,v as L,y as d,h as y,b as w,t as b,c as E,e as P,n as _,g as j,B as S,C as k,D as C,E as O,F as R,K as B}from"./index.075cb19a.js";const D="Users/aliabid/projects/gradio/ui/packages/html/src/HTML.svelte";function v(n){let e;const s={c:function(){e=y("div"),w(e,"class","output-html"),w(e,"id",n[0]),b(e,"hidden",n[1]===!1),E(e,D,8,0,219)},l:function(c){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(c,t){P(c,e,t),e.innerHTML=n[2]},p:function(c,[t]){t&4&&(e.innerHTML=c[2]),t&1&&w(e,"id",c[0]),t&2&&b(e,"hidden",c[1]===!1)},i:_,o:_,d:function(c){c&&j(e)}};return h("SvelteRegisterBlock",{block:s,id:v.name,type:"component",source:"",ctx:n}),s}function N(n,e,s){let{$$slots:r={},$$scope:c}=e;L("HTML",r,[]);let{elem_id:t=""}=e,{visible:l=!0}=e,{value:a}=e;const u=d(),m=["elem_id","visible","value"];return Object.keys(e).forEach(i=>{!~m.indexOf(i)&&i.slice(0,2)!=="$$"&&i!=="slot"&&console.warn(`<HTML> was created with unknown prop '${i}'`)}),n.$$set=i=>{"elem_id"in i&&s(0,t=i.elem_id),"visible"in i&&s(1,l=i.visible),"value"in i&&s(2,a=i.value)},n.$capture_state=()=>({createEventDispatcher:d,elem_id:t,visible:l,value:a,dispatch:u}),n.$inject_state=i=>{"elem_id"in i&&s(0,t=i.elem_id),"visible"in i&&s(1,l=i.visible),"value"in i&&s(2,a=i.value)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&4&&u("change")},[t,l,a]}class M extends g{constructor(e){super(e),p(this,e,N,v,H,{elem_id:0,visible:1,value:2}),h("SvelteRegisterComponent",{component:this,tagName:"HTML",options:e,id:v.name});const{ctx:s}=this.$$,r=e.props||{};s[2]===void 0&&!("value"in r)&&console.warn("<HTML> was created without expected prop 'value'")}get elem_id(){throw new Error("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function f(n){let e,s;e=new M({props:{value:n[2],elem_id:n[0],visible:n[1]},$$inline:!0}),e.$on("change",n[4]);const r={c:function(){S(e.$$.fragment)},l:function(t){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(t,l){k(e,t,l),s=!0},p:function(t,[l]){const a={};l&4&&(a.value=t[2]),l&1&&(a.elem_id=t[0]),l&2&&(a.visible=t[1]),e.$set(a)},i:function(t){s||(C(e.$$.fragment,t),s=!0)},o:function(t){O(e.$$.fragment,t),s=!1},d:function(t){R(e,t)}};return h("SvelteRegisterBlock",{block:r,id:f.name,type:"component",source:"",ctx:n}),r}function q(n,e,s){let{$$slots:r={},$$scope:c}=e;L("HTML",r,[]);let{label:t}=e,{elem_id:l=""}=e,{visible:a=!0}=e,{value:u=""}=e;const m=d(),i=["label","elem_id","visible","value"];Object.keys(e).forEach(o=>{!~i.indexOf(o)&&o.slice(0,2)!=="$$"&&o!=="slot"&&console.warn(`<HTML> was created with unknown prop '${o}'`)});function T(o){B.call(this,n,o)}return n.$$set=o=>{"label"in o&&s(3,t=o.label),"elem_id"in o&&s(0,l=o.elem_id),"visible"in o&&s(1,a=o.visible),"value"in o&&s(2,u=o.value)},n.$capture_state=()=>({createEventDispatcher:d,HTML:M,label:t,elem_id:l,visible:a,value:u,dispatch:m}),n.$inject_state=o=>{"label"in o&&s(3,t=o.label),"elem_id"in o&&s(0,l=o.elem_id),"visible"in o&&s(1,a=o.visible),"value"in o&&s(2,u=o.value)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&8&&m("change")},[l,a,u,t,T]}class F extends g{constructor(e){super(e),p(this,e,q,f,H,{label:3,elem_id:0,visible:1,value:2}),h("SvelteRegisterComponent",{component:this,tagName:"HTML_1",options:e,id:f.name});const{ctx:s}=this.$$,r=e.props||{};s[3]===void 0&&!("label"in r)&&console.warn("<HTML> was created without expected prop 'label'")}get label(){throw new Error("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}var U=F;const z=["static"];export{U as Component,z as modes};
