{"version":3,"file":"vendors-node_modules_nurbs_nurbs_js.6ab25e5ff40c3c2fa9ef.js","mappings":";;;;;;;;;AAAa;;AAEb,gBAAgB,mBAAO,CAAC,4EAAwB;AAChD,sBAAsB,mBAAO,CAAC,0EAAuB;AACrD,gBAAgB,mBAAO,CAAC,4EAAwB;AAChD,oBAAoB,mBAAO,CAAC,sFAA6B;AACzD,sBAAsB,mBAAO,CAAC,wFAA8B;AAC5D,0BAA0B,mBAAO,CAAC,oFAA4B;AAC9D,kBAAkB,mBAAO,CAAC,kFAA2B;;AAErD,sBAAsB,mBAAO,CAAC,4DAAgB;AAC9C,sBAAsB,mBAAO,CAAC,8DAAiB;AAC/C,oBAAoB,mBAAO,CAAC,0DAAe;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAqD;AAC9F,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAqD;AAC9F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChUA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,gEAAgB;AACrC,eAAe,mBAAO,CAAC,oEAAkB;AACzC,uBAAuB,mBAAO,CAAC,sFAA2B;AAC1D,gBAAgB,mBAAO,CAAC,wEAAoB;AAC5C,kBAAkB,mBAAO,CAAC,8EAAuB;AACjD,iBAAiB,mBAAO,CAAC,0EAAqB;;AAE9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;;AAEA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;AAER,uBAAuB;;AAEvB;AACA,8CAA8C;AAC9C,0BAA0B,0BAA0B,MAAM;AAC1D,iCAAiC;AACjC,4GAA4G;AAC5G,6MAA6M;AAC7M,aAAa;AACb,WAAW;AACX;;AAEA,cAAc,qBAAqB;AACnC,gFAAgF;AAChF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,mCAAmC;AACnC,iDAAiD;AACjD,uDAAuD;AACvD,0EAA0E;AAC1E,4CAA4C;AAC5C,aAAa;;AAEb;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;AACA,gHAAgH;AAChH;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,YAAY;AACZ,6GAA6G;AAC7G;AACA,UAAU;AACV,2GAA2G;AAC3G;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,2EAA2E;AAC3E,QAAQ;AACR,sDAAsD;AACtD,qGAAqG;AACrG,+GAA+G;AAC/G;;AAEA;AACA,+BAA+B,gBAAgB;AAC/C;AACA,oEAAoE;AACpE;;AAEA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA,yFAAyF;AACzF;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA,sBAAsB,qBAAqB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA,iFAAiF;AACjF,KAAK;AACL;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,0GAA0G;AAC1G,QAAQ;AACR,iFAAiF;AACjF;AACA,MAAM;AACN,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA,mHAAmH;AACnH,UAAU;AACV,0FAA0F;AAC1F;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,yBAAyB,QAAQ;AACjC;AACA,gBAAgB,eAAe;AAC/B;AACA,0BAA0B,OAAO;AACjC;;AAEA;AACA,oGAAoG;AACpG;AACA,0EAA0E;AAC1E,4BAA4B;AAC5B;AACA,UAAU;AACV,kJAAkJ;AAClJ,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,4FAA4F;AAC5F,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G;AAC/G,cAAc;AACd;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA,8HAA8H;AAC9H;AACA;AACA,YAAY;AACZ;AACA,2FAA2F;AAC3F,cAAc;AACd,0BAA0B,oBAAoB;AAC9C;AACA,6FAA6F;AAC7F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,MAAM;AACN,4CAA4C;AAC5C;AACA,IAAI;AACJ,gBAAgB,oBAAoB;AACpC;AACA,gGAAgG;AAChG,QAAQ;AACR,oEAAoE;AACpE;AACA;AAC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CA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AClDa;;AAEb,gBAAgB,mBAAO,CAAC,kEAAc;AACtC,qBAAqB,mBAAO,CAAC,8DAAY;;AAEzC;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AC9Da;;AAEb,gBAAgB,mBAAO,CAAC,kEAAc;AACtC,oBAAoB,mBAAO,CAAC,4EAAmB;AAC/C,kBAAkB,mBAAO,CAAC,wEAAiB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/Ba;;AAEb;AACA;AACA;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVa;;AAEb;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBa;;AAEb,oBAAoB,mBAAO,CAAC,4EAAmB;;AAE/C;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBa;;AAEb;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,0CAA0C;AACnF;AACA;AACA;;AAEA","sources":["webpack://pgljupyter/./node_modules/nurbs/nurbs.js","webpack://pgljupyter/./node_modules/nurbs/src/evaluate.js","webpack://pgljupyter/./node_modules/nurbs/src/numerical-derivative.js","webpack://pgljupyter/./node_modules/nurbs/src/support.js","webpack://pgljupyter/./node_modules/nurbs/src/transform.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/accessor-preamble.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/cache-key.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/create-accessors.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/infer-type.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/is-array-like.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/is-ndarray-like.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/is-ndarray.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/ndloop.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/size-getter.js","webpack://pgljupyter/./node_modules/nurbs/src/utils/variable.js"],"sourcesContent":["'use strict';\n\nvar inferType = require('./src/utils/infer-type');\nvar computeCacheKey = require('./src/utils/cache-key');\nvar isNdarray = require('./src/utils/is-ndarray');\nvar isNdarrayLike = require('./src/utils/is-ndarray-like');\nvar createAccessors = require('./src/utils/create-accessors');\nvar numericalDerivative = require('./src/numerical-derivative');\nvar isArrayLike = require('./src/utils/is-array-like');\n\nvar createEvaluator = require('./src/evaluate');\nvar createTransform = require('./src/transform');\nvar createSupport = require('./src/support');\n\nvar BOUNDARY_TYPES = {\n  open: 'open',\n  closed: 'closed',\n  clamped: 'clamped'\n};\n\nfunction isBlank (x) {\n  return x === undefined || x === null;\n}\n\nfunction parseNURBS (points, degree, knots, weights, boundary, opts) {\n  var i, dflt;\n\n  if (points && !isArrayLike(points) && !isNdarray(points)) {\n    opts = points;\n    this.debug = points.debug;\n    this.checkBounds = !!points.checkBounds;\n    this.weights = points.weights;\n    this.knots = points.knots;\n    this.degree = points.degree;\n    this.boundary = points.boundary;\n    this.points = points.points;\n    Object.defineProperty(this, 'size', {value: opts.size, writable: true, configurable: true});\n  } else {\n    opts = opts || {};\n    this.weights = weights;\n    this.knots = knots;\n    this.degree = degree;\n    this.points = points;\n    this.boundary = boundary;\n    this.debug = opts.debug;\n    this.checkBounds = !!opts.checkBounds;\n    Object.defineProperty(this, 'size', {value: opts.size, writable: true, configurable: true});\n  }\n\n  var pointType = inferType(this.points);\n  var weightType = inferType(this.weights);\n  var knotType = inferType(this.knots);\n\n  if (this.points) {\n    //\n    // Sanitize the points\n    //\n    switch (pointType) {\n      case inferType.GENERIC_NDARRAY:\n      case inferType.NDARRAY:\n        Object.defineProperties(this, {\n          splineDimension: {\n            value: this.points.shape.length - 1,\n            writable: false,\n            configurable: true\n          },\n          dimension: {\n            value: this.points.shape[this.points.shape.length - 1],\n            writable: false,\n            configurable: true\n          },\n          size: {\n            get: function () {\n              return this.points.shape.slice(0, this.points.shape.length - 1);\n            },\n            set: function () {\n              throw new Error(\"Cannot assign to read only property 'size'\");\n            },\n            configurable: true\n          }\n        });\n        break;\n\n      case inferType.ARRAY_OF_ARRAYS:\n        // Follow the zeroth entries until we hit something that's not an array\n        var splineDimension = 0;\n        var size = this.size || [];\n        size.length = 0;\n        for (var ptr = this.points; isArrayLike(ptr[0]); ptr = ptr[0]) {\n          splineDimension++;\n          size.push(ptr.length);\n        }\n        if (splineDimension === 0) {\n          throw new Error('Expected an array of points');\n        }\n\n        Object.defineProperties(this, {\n          splineDimension: {\n            value: splineDimension,\n            writable: false,\n            configurable: true\n          },\n          dimension: {\n            value: ptr.length,\n            writable: false,\n            configurable: true\n          },\n          size: {\n            get: function () {\n              var size = [];\n              size.length = 0;\n              for (var i = 0, ptr = this.points; i < this.splineDimension; i++, ptr = ptr[0]) {\n                size[i] = ptr.length;\n              }\n              return size;\n            },\n            set: function () {\n              throw new Error(\"Cannot assign to read only property 'size'\");\n            },\n            configurable: true\n          }\n        });\n\n        break;\n      case inferType.PACKED:\n      default:\n        throw new Error('Expected either a packed array, array of arrays, or ndarray of points');\n    }\n  } else {\n    if (this.size === undefined || this.size === null) {\n      throw new Error('Either points or a control hull size must be provided.');\n    }\n    if (!isArrayLike(this.size)) {\n      Object.defineProperty(this, 'size', {\n        value: [this.size],\n        writable: true,\n        configurable: true\n      });\n    }\n    if (this.size.length === 0) {\n      throw new Error('`size` must be a number or an array of length at least one.');\n    }\n\n    Object.defineProperties(this, {\n      splineDimension: {\n        value: this.size.length,\n        writable: false,\n        configurable: true\n      },\n      dimension: {\n        value: 0,\n        writable: false,\n        configurable: true\n      }\n    });\n  }\n\n  //\n  // Sanitize the degree into an array\n  //\n  if (isArrayLike(this.degree)) {\n    for (i = 0; i < this.splineDimension; i++) {\n      if (isBlank(this.degree[i])) {\n        throw new Error('Missing degree in dimension ' + (i + 1));\n      }\n    }\n  } else {\n    var hasBaseDegree = !isBlank(this.degree);\n    var baseDegree = isBlank(this.degree) ? 2 : this.degree;\n    this.degree = [];\n    for (i = 0; i < this.splineDimension; i++) {\n      if (this.size[i] <= baseDegree) {\n        if (hasBaseDegree) {\n          throw new Error('Expected at least ' + (baseDegree + 1) + ' points for degree ' + baseDegree + ' spline in dimension ' + (i + 1) + ' but got only ' + this.size[i]);\n        } else {\n          this.degree[i] = this.size[i] - 1;\n        }\n      } else {\n        this.degree[i] = baseDegree;\n      }\n    }\n  }\n\n  //\n  // Sanitize boundaries\n  //\n  dflt = (typeof this.boundary !== 'string') ? 'open' : this.boundary;\n  if (!BOUNDARY_TYPES[dflt]) {\n    throw new Error('Boundary type must be one of ' + Object.keys(BOUNDARY_TYPES) + '. Got ' + dflt);\n  }\n  this.boundary = isArrayLike(this.boundary) ? this.boundary : [];\n  this.boundary.length = this.splineDimension;\n  for (i = 0; i < this.splineDimension; i++) {\n    this.boundary[i] = isBlank(this.boundary[i]) ? dflt : this.boundary[i];\n\n    if (!BOUNDARY_TYPES[dflt]) {\n      throw new Error('Boundary type must be one of ' + Object.keys(BOUNDARY_TYPES) + '. Got ' + dflt + ' for dimension ' + (i + 1));\n    }\n  }\n\n  //\n  // Sanitize knots\n  //\n  switch (knotType) {\n    case inferType.ARRAY_OF_ARRAYS:\n      // Wrap flat arrays in an array so that curves are more natural\n      if (isArrayLike(this.knots) && this.knots.length > 0 && !isArrayLike(this.knots[0])) {\n        this.knots = [this.knots];\n      }\n\n      for (i = 0; i < this.splineDimension; i++) {\n        if (this.size[i] <= this.degree[i]) {\n          throw new Error('Expected at least ' + (this.degree[i] + 1) + ' points in dimension ' + (i + 1) + ' but got ' + this.size[i] + '.');\n        }\n\n        if (isArrayLike(this.knots[i])) {\n          if (this.boundary[i] !== 'closed' && this.knots[i].length !== this.degree[i] + this.size[i] + 1) {\n            throw new Error('Expected ' + (this.degree[i] + this.size[i] + 1) + ' knots in dimension ' + (i + 1) + ' but got ' + this.knots[i].length + '.');\n          } else if (this.boundary[i] === 'closed' && this.knots[i].length !== this.size[i] + 1) {\n            // Fudge factor allowance for just ignoring extra knots. This makes some allowance\n            // for passing regular clamped/open spline knots to a closed spline by ignoring extra\n            // knots instead of simply truncating.\n            var canBeFudged = this.knots[i].length === this.size[i] + this.degree[i] + 1;\n            if (!canBeFudged) {\n              throw new Error('Expected ' + (this.size[i] + 1) + ' knots for closed spline in dimension ' + (i + 1) + ' but got ' + this.knots[i].length + '.');\n            }\n          }\n        }\n      }\n      break;\n    case inferType.NDARRAY:\n      break;\n  }\n\n  //\n  // Create evaluator\n  //\n  var newCacheKey = computeCacheKey(this, this.debug, this.checkBounds, pointType, weightType, knotType);\n\n  if (newCacheKey !== this.__cacheKey) {\n    this.__cacheKey = newCacheKey;\n\n    var accessors = createAccessors(this);\n\n    this.evaluate = createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, false);\n    this.transform = createTransform(this.__cacheKey, this, accessors, this.debug);\n    this.support = createSupport(this.__cacheKey, this, accessors, this.debug, this.checkBounds);\n\n    this.evaluator = function (derivativeOrder, isBasis) {\n      return createEvaluator(this.__cacheKey, this, accessors, this.debug, this.checkBounds, isBasis, derivativeOrder);\n    };\n  }\n\n  this.numericalDerivative = numericalDerivative.bind(this);\n\n  return this;\n}\n\nfunction domainGetter () {\n  var sizeArray;\n  var ret = [];\n\n  // If the reference to size is hard-coded, then the size cannot change, or\n  // if you change points manually (like by appending a point) without re-running\n  // the constructor, then it'll be incorrect. This aims for middle-ground\n  // by querying the size directly, based on the point data type\n  //\n  // A pointer to the point array-of-arrays:\n  var ptr = this.points;\n\n  if (!ptr) {\n    // If there are no points, then just use this.size\n    sizeArray = this.size;\n  } else if (isNdarrayLike(ptr)) {\n    // If it's an ndarray, use the ndarray's shape property\n    sizeArray = ptr.shape;\n  }\n\n  for (var d = 0; d < this.splineDimension; d++) {\n    var size = sizeArray ? sizeArray[d] : ptr.length;\n    var p = this.degree[d];\n    var isClosed = this.boundary[d] === 'closed';\n\n    if (this.knots && this.knots[d]) {\n      var k = this.knots[d];\n      ret[d] = [k[isClosed ? 0 : p], k[size]];\n    } else {\n      ret[d] = [isClosed ? 0 : p, size];\n    }\n\n    // Otherwise if it's an array of arrays, we get the size of the next\n    // dimension by recursing into the points\n    if (ptr) ptr = ptr[0];\n  }\n  return ret;\n}\n\n// Evaluate Non-Uniform Rational B-Splines (NURBS)\n// @param points {Array} - data array\n// @param degree {Array} - spline curve degree\n// @param knots {Array} - knot vector\n// @param weights {Array} - weight vector\n// @param opts {object} - additional options\nfunction nurbs (points, degree, knots, weights, boundary, opts) {\n  var ctor = function (points, degree, knots, weights, boundary, opts) {\n    parseFcn(points, degree, knots, weights, boundary, opts);\n    return ctor;\n  };\n\n  var parseFcn = parseNURBS.bind(ctor);\n\n  Object.defineProperty(ctor, 'domain', {\n    get: domainGetter\n  });\n\n  parseFcn(points, degree, knots, weights, boundary, opts);\n\n  return ctor;\n}\n\nmodule.exports = nurbs;\n","/* eslint-disable no-new-func */\n\n'use strict';\n\nvar ndloop = require('./utils/ndloop');\nvar variable = require('./utils/variable');\nvar accessorPreamble = require('./utils/accessor-preamble');\nvar inferType = require('./utils/infer-type');\nvar isArrayLike = require('./utils/is-array-like');\nvar sizeGetter = require('./utils/size-getter');\n\nvar evaluatorCache = {};\nvar codeCache = {};\n\nmodule.exports = function (cacheKey, nurbs, accessors, debug, checkBounds, isBasis, derivative) {\n  var splineDimension = nurbs.splineDimension;\n  var i, j, n, m, d, kvar;\n\n  var points = nurbs.points;\n  var degree = nurbs.degree;\n  var weights = nurbs.weights;\n  var hasWeights = weights !== undefined;\n  var knots = nurbs.knots;\n  var spaceDimension = nurbs.dimension;\n  var boundary = nurbs.boundary;\n\n  if (derivative !== undefined && derivative !== null) {\n    if (!Array.isArray(derivative)) {\n      derivative = [derivative];\n    }\n    var totalDerivativeOrder = 0;\n    for (i = 0; i < splineDimension; i++) {\n      if (derivative[i] === undefined) derivative[i] = 0;\n      totalDerivativeOrder += derivative[i];\n    }\n    if (hasWeights && totalDerivativeOrder > 1) {\n      throw new Error('Analytical derivative not implemented for rational b-splines with order n = ' + totalDerivativeOrder + '.');\n    }\n  }\n\n  if (isBasis) cacheKey = 'Basis' + cacheKey;\n  if (derivative) cacheKey = 'Der' + derivative.join('_') + '_' + cacheKey;\n  var cachedEvaluator = evaluatorCache[cacheKey];\n  if (debug) {\n    var logger = typeof debug === 'function' ? debug : console.log;\n  }\n\n  if (cachedEvaluator) {\n    if (debug) {\n      logger(codeCache[cacheKey]);\n    }\n\n    return cachedEvaluator.bind(nurbs);\n  }\n\n  var code = [];\n  var functionName = 'evaluate' + cacheKey;\n\n  var pointAccessor = accessors.point;\n  if (isBasis) {\n    pointAccessor = function (src, period) {\n      var terms = [];\n      for (var i = 0; i < src.length; i++) {\n        var accessor = src[i];\n        var terms2 = [];\n        for (var j = 0; j < accessor.length; j++) {\n          if (accessor[j] !== 0) terms2.push(accessor[j]);\n        }\n        accessor = terms2.join(' + ');\n        if (period[i]) {\n          accessor = '(' + accessor + ' + ' + period[i] + ') % ' + period[i];\n        }\n        terms.push(accessor + ' === ' + indexVar(i));\n      }\n      return '((' + terms.join(' && ') + ') ? 1 : 0)';\n    };\n  }\n  var weightAccessor = accessors.weight;\n  var knotAccessor = accessors.knot;\n\n  var knotVar = variable('k');\n  var pointVar = variable('x');\n  var weightVar = variable('w');\n  var indexVar = variable('i');\n  var tVar = variable('t');\n  var domainVar = debug ? 'domain' : 'd';\n  var sizeVar = variable(debug ? 'size' : 's');\n  var knotIndex = variable(debug ? 'knotIndex' : 'j');\n\n  var allDimensionUniform = true;\n  for (d = 0; d < splineDimension; d++) {\n    if (isArrayLike(knots) && isArrayLike(knots[d])) {\n      allDimensionUniform = false;\n    }\n  }\n\n  // Just to indent properly and save lots of typing\n  function line (str) {\n    code.push('  ' + (str || ''));\n  }\n  function debugLine (str) {\n    if (debug) line(str);\n  }\n  // function clog (str) {\n    // if (debug) code.push('console.log(\"' + str + ' =\", ' + str + ');');\n  // }\n\n  if (isBasis) {\n    var indexArgs = [];\n  }\n  var parameterArgs = [];\n  for (i = 0; i < splineDimension; i++) {\n    if (isBasis) {\n      indexArgs.push(indexVar([i]));\n    }\n    parameterArgs.push(tVar([i]));\n  }\n\n  code.push('function ' + functionName + ' (' +\n    (isBasis ? '' : 'out, ') +\n    parameterArgs.join(', ') +\n    (isBasis ? ', ' + indexArgs.join(', ') : '') +\n    ') {');\n\n  line('var h, m, a, b;');\n\n  if (checkBounds) {\n    line('var ' + domainVar + ' = this.domain;');\n    line('for (var i = 0; i < this.splineDimension; i++) {');\n    line('  a = arguments[i + 1];');\n    line('  if (a < ' + domainVar + '[i][0] || a > ' + domainVar + '[i][1] || a === undefined || isNaN(a)) {');\n    line('    throw new Error(\\'Invalid Spline parameter in dimension \\'+i+\\'. Valid domain is [\\'+' + domainVar + '[i][0]+\\', \\'+' + domainVar + '[i][1]+\\']. but got t\\'+i+\\' = \\'+arguments[i + 1]+\\'.\\');');\n    line('  }');\n    line('}');\n  }\n\n  for (d = 0; d < splineDimension; d++) {\n    line('var ' + sizeVar(d) + ' = ' + sizeGetter(points, 'this.points', d) + ';');\n  }\n  code.push(accessorPreamble(nurbs, 'x', 'this.points', points));\n\n  if (hasWeights) {\n    code.push(accessorPreamble(nurbs, 'w', 'this.weights', weights));\n  }\n\n  if (!allDimensionUniform) {\n    code.push(accessorPreamble(nurbs, 'k', 'this.knots', knots));\n  }\n\n  function ternary (cond, a, b) {\n    return '(' + cond + ') ? (' + a + ') : (' + b + ')';\n  }\n\n  var hasKnots = [];\n  for (d = 0; d < splineDimension; d++) {\n    switch (inferType(knots)) {\n      case inferType.NDARRAY:\n        hasKnots[d] = true;\n        break;\n      case inferType.ARRAY_OF_ARRAYS:\n        hasKnots[d] = isArrayLike(knots[d]);\n        break;\n    }\n  }\n\n  for (d = 0; d < splineDimension; d++) {\n    if (hasKnots[d]) {\n      //\n      // LOCATE KNOTS\n      //\n      debugLine('\\n  // Bisect to locate the knot interval in dimension ' + d + '\\n');\n      line('var ' + knotIndex(d) + ' = 0;');\n      line('h = ' + sizeVar(d) + ';');\n      line('while(h > ' + knotIndex(d) + ' + 1) {');\n      line('  m = 0.5 * (h + ' + knotIndex(d) + ') | 0;');\n      line('  if (' + knotAccessor([d, 'm']) + ' > ' + tVar(d) + ') h = m;');\n      line('  else ' + knotIndex(d) + ' = m;');\n      line('}');\n\n      debugLine('\\n  // Fetch knots for dimension ' + d + '\\n');\n\n      for (i = -degree[d] + 1; i <= degree[d]; i++) {\n        if (boundary[d] === 'closed') {\n          if (i < 0) {\n            // line('var ' + knotVar([d, i + degree[d] - 1]) + ' = ' + knotAccessor([d, [knotIndex(d), i]]) + ';');\n            // EDIT THIS SECTION\n            line('var ' + knotVar([d, i + degree[d] - 1]) + ' = ' + ternary(\n              knotIndex(d) + ' < ' + (-i),\n              knotAccessor([d, 0]) + ' + ' + knotAccessor([d, [sizeVar(d), knotIndex(d), i]]) + ' - ' + knotAccessor([d, [sizeVar(d)]]),\n              knotAccessor([d, [knotIndex(d), i]])\n            ) + ';');\n          } else if (i > 0) {\n            line('var ' + knotVar([d, i + degree[d] - 1]) + ' = ' + ternary(\n              knotIndex(d) + ' + ' + i + ' > ' + sizeVar(d),\n              // knotAccessor([d, sizeVar(d)]) + ' + ' + knotAccessor([d, i]) + ' - ' + knotAccessor([d, 0]),\n              knotAccessor([d, sizeVar(d)]) + ' + ' + knotAccessor([d, i + ' + ' + knotIndex(d) + ' - ' + sizeVar(d)]) + ' - ' + knotAccessor([d, 0]),\n              knotAccessor([d, [knotIndex(d), i]])\n            ) + ';');\n          } else {\n            line('var ' + knotVar([d, i + degree[d] - 1]) + ' = ' + knotAccessor([d, [knotIndex(d), i]]) + ';');\n          }\n        } else {\n          line('var ' + knotVar([d, i + degree[d] - 1]) + ' = ' + knotAccessor([d, [knotIndex(d), i]]) + ';');\n        }\n      }\n    } else {\n      //\n      // UNIFORM B-SPLINE\n      //\n      debugLine('\\n  // Directly compute knot interval for dimension ' + d + '\\n');\n\n      if (boundary[d] === 'closed') {\n        line(knotIndex(d) + ' = (' + tVar(d) + ' | 0) % ' + sizeVar(d) + ';');\n      } else {\n        line(knotIndex(d) + ' = (' + tVar(d) + ' | 0);');\n        line('if (' + knotIndex(d) + ' < ' + degree[d] + ') ' + knotIndex(d) + ' = ' + degree[d] + ';');\n        line('if (' + knotIndex(d) + ' > ' + sizeVar(d) + ' - 1) ' + knotIndex(d) + ' = ' + sizeVar(d) + ' - 1;');\n      }\n\n      debugLine('\\n  // Compute and clamp knots for dimension ' + d + '\\n');\n      for (i = -degree[d] + 1; i <= degree[d]; i++) {\n        kvar = knotVar([d, i + degree[d] - 1]);\n        line('var ' + kvar + ' = ' + knotIndex(d) + ' + ' + (i) + ';');\n      }\n\n      if (boundary[d] === 'clamped') {\n        for (i = -degree[d] + 1; i <= degree[d]; i++) {\n          kvar = knotVar([d, i + degree[d] - 1]);\n          if (i < 0) {\n            line('if (' + kvar + ' < ' + degree[d] + ') ' + kvar + ' = ' + degree[d] + ';');\n          }\n          if (i > 0) {\n            line('if (' + kvar + ' > ' + sizeVar(d) + ') ' + kvar + ' = ' + sizeVar(d) + ';');\n          }\n        }\n      }\n\n      if (boundary[d] === 'closed') {\n        debugLine('\\n  // Wrap the B-Spline parameter for closed boundary');\n        line(tVar(d) + ' %= ' + sizeVar(d) + ';');\n      }\n    }\n  }\n\n  for (d = 0, n = []; d < splineDimension; d++) {\n    n[d] = degree[d] + 1;\n  }\n\n  if (hasWeights) {\n    debugLine('\\n  // Fetch weights\\n');\n    ndloop(n, function (dst) {\n      var readIdx = [];\n      var period = [];\n      for (var d = 0; d < splineDimension; d++) {\n        readIdx[d] = [knotIndex(d), dst[d] - degree[d]];\n        if (boundary[d] === 'closed' && dst[d] - degree[d] < 0) period[d] = sizeVar(d);\n      }\n      line('var ' + weightVar(dst) + ' = ' + weightAccessor(readIdx, period) + ';');\n    });\n  }\n\n  if (debug) {\n    if (hasWeights) {\n      line('\\n  // Fetch points and project into homogeneous (weighted) coordinates\\n');\n    } else {\n      line('\\n  // Fetch points\\n');\n    }\n  }\n\n  ndloop(n, function (dst) {\n    var readIdx = [];\n    var period = [];\n    for (var d = 0; d < splineDimension; d++) {\n      readIdx[d] = [knotIndex(d), dst[d] - degree[d]];\n      if (boundary[d] === 'closed' && dst[d] - degree[d] < 0) period[d] = sizeVar(d);\n    }\n    if (isBasis) {\n      if (hasWeights) {\n        line('var ' + pointVar(dst) + ' = ' + pointAccessor(readIdx, period) + ' * ' + weightVar(dst) + ';');\n      } else {\n        line('var ' + pointVar(dst) + ' = ' + pointAccessor(readIdx, period) + ';');\n      }\n    } else {\n      for (d = 0; d < spaceDimension; d++) {\n        var dstWithDim = dst.concat(d);\n        readIdx[splineDimension] = d;\n        if (hasWeights) {\n          line('var ' + pointVar(dstWithDim) + ' = ' + pointAccessor(readIdx, period) + ' * ' + weightVar(dst) + ';');\n        } else {\n          line('var ' + pointVar(dstWithDim) + ' = ' + pointAccessor(readIdx, period) + ';');\n        }\n      }\n    }\n  });\n  debugLine('\\n');\n\n  debugLine('// Perform De Boor\\'s algorithm');\n  for (d = n.length - 1; d >= 0; d--) {\n    n[d] = [degree[d], degree[d] + 1];\n    for (i = 0; i < degree[d]; i++) {\n      debugLine('\\n  // Degree ' + degree[d] + ' evaluation in dimension ' + d + ', step ' + (i + 1) + '\\n');\n      for (j = degree[d]; j > i; j--) {\n        var isDerivative = derivative && (degree[d] - i - derivative[d] <= 0);\n\n        if (isDerivative) {\n          line('m = 1 / (' + knotVar([d, j - i + degree[d] - 1]) + ' - ' + knotVar([d, j - 1]) + ');');\n          if (hasWeights) {\n            line('a = (' + tVar(d) + ' - ' + knotVar([d, j - 1]) + ') * m;');\n            line('b = 1 - a;');\n          }\n        } else {\n          line('a = (' + tVar(d) + ' - ' + knotVar([d, j - 1]) + ') / (' + knotVar([d, j - i + degree[d] - 1]) + ' - ' + knotVar([d, j - 1]) + ');');\n          line('b = 1 - a;');\n        }\n\n        if (hasWeights) {\n          ndloop(n, function (ii) {\n            var ij = ii.slice();\n            var ij1 = ii.slice();\n            ij[d] = j;\n            ij1[d] = j - 1;\n            if (isDerivative && hasWeights) line('h = ' + weightVar(ij) + ';');\n            line(weightVar(ij) + ' = b * ' + weightVar(ij1) + ' + a * ' + weightVar(ij) + ';');\n          });\n        }\n        ndloop(n, function (ii) {\n          var weightFactor, pt1, pt2;\n          var ij = ii.slice();\n          var ij1 = ii.slice();\n          // Replace the dimension being interpolated with the interpolation indices\n          ij[d] = j;\n          ij1[d] = j - 1;\n          // Create a version to which we can append the dimension when we loop over spatial dimension\n          if (isDerivative) {\n            var derivCoeff = i + 1;\n            if (isBasis) {\n              weightFactor = hasWeights ? 'h * ' + weightVar(ij1) + ' / ' + weightVar(ij) + ' * ' : '';\n              pt1 = pointVar(ij) + (hasWeights ? ' / h' : '');\n              pt2 = pointVar(ij1) + (hasWeights ? ' / ' + weightVar(ij1) : '');\n              line(pointVar(ij) + ' = ' + derivCoeff + ' * ' + weightFactor + '(' + pt1 + ' - ' + pt2 + ') * m;');\n            } else {\n              var ijWithDimension = ij.slice();\n              var ij1WithDimension = ij1.slice();\n              for (m = 0; m < spaceDimension; m++) {\n                ijWithDimension[splineDimension] = ij1WithDimension[splineDimension] = m;\n                weightFactor = hasWeights ? 'h * ' + weightVar(ij1) + ' / ' + weightVar(ij) + ' * ' : '';\n                pt1 = pointVar(ijWithDimension) + (hasWeights ? ' / h' : '');\n                pt2 = pointVar(ij1WithDimension) + (hasWeights ? ' / ' + weightVar(ij1) : '');\n                line(pointVar(ijWithDimension) + ' = ' + derivCoeff + ' * ' + weightFactor + '(' + pt1 + ' - ' + pt2 + ') * m;');\n              }\n            }\n          } else {\n            if (isBasis) {\n              line(pointVar(ij) + ' = b * ' + pointVar(ij1) + ' + a * ' + pointVar(ij) + ';');\n            } else {\n              for (m = 0; m < spaceDimension; m++) {\n                ij[splineDimension] = ij1[splineDimension] = m;\n                line(pointVar(ij) + ' = b * ' + pointVar(ij1) + ' + a * ' + pointVar(ij) + ';');\n              }\n            }\n          }\n        });\n        debugLine('\\n');\n      }\n    }\n  }\n\n  if (debug) {\n    if (hasWeights) {\n      line('\\n  // Project back from homogeneous coordinates and return final output\\n');\n    } else {\n      line('\\n  // Return final output\\n');\n    }\n  }\n  if (isBasis) {\n    if (hasWeights) {\n      line('return ' + pointVar(degree) + ' / ' + weightVar(degree) + ';');\n    } else {\n      line('return ' + pointVar(degree) + ';');\n    }\n  } else {\n    for (d = 0; d < spaceDimension; d++) {\n      if (hasWeights) {\n        line('out[' + d + '] = ' + pointVar(degree.concat([d])) + ' / ' + weightVar(degree) + ';');\n      } else {\n        line('out[' + d + '] = ' + pointVar(degree.concat([d])) + ';');\n      }\n    }\n  }\n  if (!isBasis) {\n    line('return out;');\n  }\n  code.push('}');\n\n  if (debug) {\n    var codeStr = code.join('\\n');\n    logger(codeStr);\n\n    codeCache[cacheKey] = codeStr;\n  }\n\n  var evaluator = new Function([code.join('\\n'), '; return ', functionName].join(''))();\n  evaluatorCache[cacheKey] = evaluator;\n  return evaluator.bind(nurbs);\n};\n","'use strict';\n\nvar args = [];\nvar tmp = [];\n\nmodule.exports = function numericalDerivative (out, order, dimension) {\n  if (order !== 1) {\n    throw new Error('Numerical derivative not implemented for order n = ' + order + '.');\n  }\n\n  var i;\n  var h = arguments[this.splineDimension + 3] === undefined ? 1e-4 : arguments[this.splineDimension + 3];\n\n  args.length = this.splineDimension;\n  for (i = 0; i < this.splineDimension; i++) {\n    args[i + 1] = arguments[i + 3];\n  }\n\n  var domain = this.domain;\n  var k0 = domain[dimension][0];\n  var k1 = domain[dimension][1];\n\n  var tm, tp, T;\n  var t0 = args[dimension + 1];\n  var dt = (k1 - k0) * h;\n  if (this.boundary[dimension] === 'closed') {\n    T = k1 - k0;\n    tm = k0 + ((t0 - k0 - dt + T) % T);\n    tp = k0 + ((t0 - k0 + dt + T) % T);\n    dt *= 2;\n  } else {\n    tm = Math.min(k1, Math.max(k0, t0 - dt));\n    tp = Math.min(k1, Math.max(k0, t0 + dt));\n    dt = tp - tm;\n  }\n\n  args[dimension + 1] = tm;\n  args[0] = tmp;\n  this.evaluate.apply(null, args);\n\n  args[dimension + 1] = tp;\n  args[0] = out;\n  this.evaluate.apply(null, args);\n\n  for (i = 0; i < this.dimension; i++) {\n    out[i] = (out[i] - tmp[i]) / dt;\n  }\n\n  return out;\n};\n","/* eslint-disable no-new-func */\n\n'use strict';\n\nvar ndloop = require('./utils/ndloop');\nvar variable = require('./utils/variable');\nvar accessorPreamble = require('./utils/accessor-preamble');\nvar inferType = require('./utils/infer-type');\nvar isArrayLike = require('./utils/is-array-like');\nvar sizeGetter = require('./utils/size-getter');\n\nvar supportCache = {};\n\nmodule.exports = function (cacheKey, nurbs, accessors, debug, checkBounds) {\n  var cachedSupport = supportCache[cacheKey];\n  if (cachedSupport) {\n    return cachedSupport.bind(nurbs);\n  }\n\n  var degree = nurbs.degree;\n  var knots = nurbs.knots;\n  var splineDimension = nurbs.splineDimension;\n  var boundary = nurbs.boundary;\n\n  var i, n, d;\n  var code = [];\n  var functionName = 'support' + cacheKey;\n\n  var knotAccessor = accessors.knot;\n\n  var tVar = variable('t');\n  var domainVar = debug ? 'domain' : 'd';\n  var sizeVar = variable(debug ? 'size' : 's');\n  var knotIndex = variable(debug ? 'knotIndex' : 'i');\n\n  var allDimensionUniform = true;\n  for (d = 0; d < splineDimension; d++) {\n    if (isArrayLike(knots) && isArrayLike(knots[d])) {\n      allDimensionUniform = false;\n    }\n  }\n\n  // Just to indent properly and save lots of typing\n  function line (str) {\n    code.push('  ' + (str || ''));\n  }\n\n  var parameterArgs = [];\n  for (i = 0; i < splineDimension; i++) {\n    parameterArgs.push(tVar([i]));\n  }\n\n  code.push('function ' + functionName + ' (out, ' + parameterArgs.join(', ') + ') {');\n\n  var c = 0;\n  function pushSupport (args, period) {\n    if (period === undefined) {\n      line('out[' + (c++) + '] = ' + args.join(' + ') + ';');\n    } else {\n      line('out[' + (c++) + '] = (' + args.join(' + ') + ' + ' + period + ') % ' + period + ';');\n    }\n  }\n\n  line('var h, m;');\n  line('var c = 0;');\n\n  if (checkBounds) {\n    line('var ' + domainVar + ' = this.domain;');\n    line('for (var i = 0; i < this.splineDimension; i++) {');\n    line('  a = arguments[i + 1];');\n    line('  if (a < ' + domainVar + '[i][0] || a > ' + domainVar + '[i][1] || a === undefined || isNaN(a)) {');\n    line('    throw new Error(\\'Invalid Spline parameter in dimension \\'+i+\\'. Valid domain is [\\'+' + domainVar + '[i][0]+\\', \\'+' + domainVar + '[i][1]+\\']. but got t\\'+i+\\' = \\'+arguments[i + 1]+\\'.\\');');\n    line('  }');\n    line('}');\n  }\n\n  for (d = 0; d < splineDimension; d++) {\n    line('var ' + sizeVar(d) + ' = ' + sizeGetter(nurbs.points, 'this.points', d) + ';');\n  }\n\n  if (!allDimensionUniform) {\n    code.push(accessorPreamble(nurbs, 'k', 'this.knots', knots));\n  }\n\n  var hasKnots = [];\n  for (d = 0; d < splineDimension; d++) {\n    switch (inferType(knots)) {\n      case inferType.NDARRAY:\n        hasKnots[d] = true;\n        break;\n      case inferType.ARRAY_OF_ARRAYS:\n        hasKnots[d] = isArrayLike(knots[d]);\n        break;\n    }\n  }\n\n  for (d = 0; d < splineDimension; d++) {\n    if (hasKnots[d]) {\n      line('var ' + knotIndex(d) + ' = 0;');\n      line('h = ' + sizeVar(d) + ';');\n      line('while(h > ' + knotIndex(d) + ' + 1) {');\n      line('  m = 0.5 * (h + ' + knotIndex(d) + ') | 0;');\n      line('  if (' + knotAccessor([d, 'm']) + ' > ' + tVar(d) + ') h = m;');\n      line('  else ' + knotIndex(d) + ' = m;');\n      line('}');\n    } else {\n      if (boundary[d] === 'closed') {\n        line(knotIndex(d) + ' = (' + tVar(d) + ' | 0) % ' + sizeVar(d) + ';');\n      } else {\n        line(knotIndex(d) + ' = (' + tVar(d) + ' | 0);');\n        line('if (' + knotIndex(d) + ' < ' + degree[d] + ') ' + knotIndex(d) + ' = ' + degree[d] + ';');\n        line('if (' + knotIndex(d) + ' > ' + sizeVar(d) + ' - 1) ' + knotIndex(d) + ' = ' + sizeVar(d) + ' - 1;');\n      }\n    }\n  }\n\n  for (d = 0, n = []; d < splineDimension; d++) {\n    n[d] = degree[d] + 1;\n  }\n\n  ndloop(n, function (dst) {\n    var readIdx = [];\n    var period = [];\n    for (var d = 0; d < splineDimension; d++) {\n      readIdx[d] = [knotIndex(d), dst[d] - degree[d]];\n      if (boundary[d] === 'closed' && dst[d] - degree[d] < 0) period[d] = sizeVar(d);\n    }\n    for (d = 0; d < splineDimension; d++) {\n      pushSupport(readIdx[d], period[d]);\n    }\n  });\n\n  line('out.length = ' + c + ';');\n\n  line('return out;');\n  code.push('}');\n\n  if (debug) console.log(code.join('\\n'));\n\n  var evaluator = new Function([code.join('\\n'), '; return ', functionName].join(''))();\n  supportCache[cacheKey] = evaluator;\n  return evaluator.bind(nurbs);\n};\n","/* eslint-disable no-new-func */\n\n'use strict';\n\nvar transformerCache = {};\nvar accessorPreamble = require('./utils/accessor-preamble');\nvar sizeGetter = require('./utils/size-getter');\nvar variable = require('./utils/variable');\n\nmodule.exports = function createTransform (cacheKey, nurbs, accessors, debug) {\n  var i, j, iterator, iterators, terms, n, rvalue, lvalue;\n  var cachedTransformer = transformerCache[cacheKey];\n  if (cachedTransformer) {\n    return cachedTransformer.bind(nurbs);\n  }\n\n  var code = [];\n  var functionName = 'transform' + cacheKey;\n\n  code.push('function ' + functionName + '(m) {');\n  code.push('var i, w;');\n  code.push(accessorPreamble(nurbs, 'x', 'this.points', nurbs.points));\n\n  var sizeVar = variable(debug ? 'size' : 's');\n  for (i = 0; i < nurbs.splineDimension; i++) {\n    code.push('var ' + sizeVar(i) + ' = ' + sizeGetter(nurbs.points, 'this.points', i) + ';');\n  }\n\n  iterators = [];\n  for (i = 0; i < nurbs.splineDimension; i++) {\n    iterator = 'i' + i;\n    iterators.push(iterator);\n    code.push('for (' + iterator + ' = ' + sizeVar(i) + '- 1; ' + iterator + ' >= 0; ' + iterator + '--) {');\n  }\n\n  for (i = 0; i < nurbs.dimension; i++) {\n    code.push('x' + i + ' = ' + accessors.point(iterators.concat([i])));\n  }\n\n  terms = [];\n  for (i = 0; i < nurbs.dimension; i++) {\n    terms.push('m[' + ((nurbs.dimension + 1) * (i + 1) - 1) + '] * x' + i);\n  }\n  terms.push('m[' + ((nurbs.dimension + 1) * (nurbs.dimension + 1) - 1) + ']');\n  code.push('var w = (' + terms.join(' + ') + ') || 1.0;');\n\n  for (i = 0; i < nurbs.dimension; i++) {\n    terms = [];\n    n = nurbs.dimension;\n    for (j = 0; j < n; j++) {\n      terms.push('m[' + (j * (n + 1) + i) + '] * x' + j);\n    }\n    terms.push('m[' + (j * (n + 1) + i) + ']');\n    lvalue = accessors.point(iterators.concat([i]));\n    rvalue = '(' + terms.join(' + ') + ') / w';\n    code.push(lvalue + ' = ' + rvalue + ';');\n  }\n\n  for (i = nurbs.splineDimension - 1; i >= 0; i--) {\n    code.push('}');\n  }\n\n  code.push('return this;');\n  code.push('}');\n\n  var transform = new Function([code.join('\\n'), '; return ', functionName].join(''))();\n\n  if (debug) console.log(code.join('\\n'));\n\n  transformerCache[cacheKey] = transform;\n  return transform.bind(nurbs);\n};\n","var inferType = require('./infer-type');\n\nmodule.exports = function (nurbs, variableName, propertyName, data) {\n  var i;\n  var code = [];\n\n  switch (inferType(data)) {\n    case inferType.NDARRAY:\n      code.push('  var ' + variableName + ' = ' + propertyName + '.data;');\n      code.push('  var ' + variableName + 'Offset = ' + propertyName + '.offset;');\n\n      for (i = 0; i < data.dimension; i++) {\n        code.push('  var ' + variableName + 'Stride' + i + ' = ' + propertyName + '.stride[' + i + '];');\n      }\n      break;\n    case inferType.ARRAY_OF_ARRAYS:\n      code.push('  var ' + variableName + ' = ' + propertyName + ';');\n  }\n\n  return code.join('\\n');\n};\n","'use strict';\n\nvar isArrayLike = require('./is-array-like');\n\nfunction capitalize (str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nmodule.exports = function (nurbs, debug, checkBounds, pointType, weightType, knotType) {\n  var d;\n  var degreeParts = [];\n  var hasAnyKnots = false;\n  for (d = 0; d < nurbs.splineDimension; d++) {\n    var hasKnots = isArrayLike(nurbs.knots) && isArrayLike(nurbs.knots[d]);\n    if (hasKnots) hasAnyKnots = true;\n    degreeParts.push(\n      'Deg' +\n      nurbs.degree[d] +\n      (hasKnots ? '' : 'Uniform') +\n      capitalize(nurbs.boundary[d])\n    );\n  }\n  var parts = [\n    [\n      hasAnyKnots ? 'NU' : '',\n      nurbs.weights ? 'RBS' : 'BS'\n    ].join('') +\n    nurbs.dimension + 'D',\n    degreeParts.join('_')\n  ];\n\n  if (pointType) {\n    parts.push(pointType + 'Pts');\n  }\n  if (weightType) {\n    parts.push(weightType + 'Wts');\n  }\n  if (knotType) {\n    parts.push(knotType + 'Kts');\n  }\n\n  if (debug) {\n    parts.push('debug');\n  }\n\n  if (checkBounds) {\n    parts.push('chk');\n  }\n\n  return parts.join('_');\n};\n","'use strict';\n\nvar inferType = require('./infer-type');\nvar createVariable = require('./variable');\n\nfunction wrapAccessor (callback) {\n  return function (i, period) {\n    if (i !== undefined && !Array.isArray(i)) i = [i];\n    var dimAccessors = [];\n    for (var j = 0; j < i.length; j++) {\n      dimAccessors.push(createVariable.sum(i[j]));\n    }\n    if (period) {\n      for (i = 0; i < dimAccessors.length; i++) {\n        if (period[i] === undefined) continue;\n        dimAccessors[i] = '(' + dimAccessors[i] + ' + ' + period[i] + ') % ' + period[i];\n      }\n    }\n    return callback(dimAccessors);\n  };\n}\n\nfunction createAccessor (name, data) {\n  var i;\n  if (!data) return undefined;\n  switch (inferType(data)) {\n    case inferType.ARRAY_OF_ARRAYS:\n      return wrapAccessor(function (accessors) {\n        return name + '[' + accessors.join('][') + ']';\n      });\n    case inferType.GENERIC_NDARRAY:\n      return wrapAccessor(function (accessors) {\n        return name + '.get(' + accessors.join(',') + ')';\n      });\n    case inferType.NDARRAY:\n      return wrapAccessor(function (accessors) {\n        var code = [name + 'Offset'];\n        for (i = 0; i < accessors.length; i++) {\n          code.push(name + 'Stride' + i + ' * (' + accessors[i] + ')');\n        }\n        return name + '[' + code.join(' + ') + ']';\n      });\n    case inferType.PACKED:\n    default:\n      return undefined;\n  }\n}\n\nmodule.exports = function (nurbs) {\n  var accessors = {};\n  var accessor;\n\n  accessor = createAccessor('x', nurbs.points);\n  if (accessor) accessors.point = accessor;\n\n  accessor = createAccessor('w', nurbs.weights);\n  if (accessor) accessors.weight = accessor;\n\n  accessor = createAccessor('k', nurbs.knots);\n  if (accessor) accessors.knot = accessor;\n\n  return accessors;\n};\n","'use strict';\n\nvar isNdarray = require('./is-ndarray');\nvar isNdarrayLike = require('./is-ndarray-like');\nvar isArrayLike = require('./is-array-like');\n\nfunction inferType (x) {\n  if (!x) {\n    return undefined;\n  }\n  if (isNdarray(x) || isNdarrayLike(x)) {\n    if (x.dtype === 'generic') {\n      return inferType.GENERIC_NDARRAY;\n    }\n    return inferType.NDARRAY;\n  } else {\n    if (isArrayLike(x)) {\n      // if (isArrayLike(x[0])) {\n      return inferType.ARRAY_OF_ARRAYS;\n      // }\n      // return inferType.PACKED;\n    }\n    throw new Error('Unhandled data type. Got type: ' + (typeof x));\n  }\n}\n\ninferType.ARRAY_OF_ARRAYS = 'Arr';\ninferType.NDARRAY = 'Nd';\ninferType.GENERIC_NDARRAY = 'GenNd';\ninferType.PACKED = 'PackArr';\n\nmodule.exports = inferType;\n","'use strict';\n\nmodule.exports = function isArrayLike (data) {\n  return Array.isArray(data) || ArrayBuffer.isView(data);\n};\n","module.exports = function (arr) {\n  if (!arr) return false;\n  return (\n    arr.data !== undefined &&\n    Array.isArray(arr.shape) &&\n    arr.offset !== undefined &&\n    arr.stride !== undefined\n  );\n};\n","'use strict';\n\n// Source: https://github.com/scijs/isndarray\n// By Kyle Robinson Young, MIT Licensed.\n\nmodule.exports = function (arr) {\n  if (!arr) return false;\n  if (!arr.dtype) return false;\n  var re = new RegExp('function View[0-9]+d(:?' + arr.dtype + ')+');\n  return re.test(String(arr.constructor));\n};\n","'use strict';\n\nmodule.exports = function ndloop (n, callback) {\n  for (var m = 1, k = 0, i = []; k < n.length; k++) {\n    m *= Array.isArray(n[k]) ? (n[k][1] - n[k][0]) : n[k];\n    i[k] = Array.isArray(n[k]) ? n[k][0] : 0;\n  }\n  for (var ptr = 0; ptr < m; ptr++) {\n    callback(i.slice());\n    for (k = n.length - 1; k >= 0; k--) {\n      if (i[k] === (Array.isArray(n[k]) ? n[k][1] : n[k]) - 1) {\n        i[k] = Array.isArray(n[k]) ? n[k][0] : 0;\n      } else {\n        i[k]++;\n        break;\n      }\n    }\n  }\n};\n","'use strict';\n\nvar isNdarrayLike = require('./is-ndarray-like');\n\nmodule.exports = function (data, dataVariableName, dimension) {\n  if (!data) {\n    return 'this.size[' + dimension + ']';\n  } else if (isNdarrayLike(data)) {\n    return dataVariableName + '.shape[' + dimension + ']';\n  } else {\n    var str = dataVariableName;\n    for (var i = 0; i < dimension; i++) {\n      str += '[0]';\n    }\n    return str + '.length';\n  }\n};\n","'use strict';\n\nvar createVariable = function createVariable (name, nurbs) {\n  return function (i, period) {\n    if (i !== undefined && !Array.isArray(i)) i = [i];\n    var dimAccessors = [];\n    for (var j = 0; j < i.length; j++) {\n      dimAccessors.push(createVariable.sum(i[j]));\n    }\n    if (period) {\n      for (i = 0; i < dimAccessors.length; i++) {\n        if (period[i] === undefined) continue;\n        dimAccessors[i] = '(' + dimAccessors[i] + ' + ' + period[i] + ') % ' + period[i];\n      }\n    }\n    return name + dimAccessors.join('_');\n  };\n};\n\ncreateVariable.sum = function (parts) {\n  parts = Array.isArray(parts) ? parts : [parts];\n  parts = parts.filter(function (part) { return part !== undefined && part !== 0; });\n  if (parts.length === 0) parts.push(0);\n  return parts.join(' + ');\n};\n\nmodule.exports = createVariable;\n"],"names":[],"sourceRoot":""}